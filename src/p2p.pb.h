// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: p2p.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_p2p_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_p2p_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_p2p_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_p2p_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[26]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_p2p_2eproto;
namespace proto {
class addr;
struct addrDefaultTypeInternal;
extern addrDefaultTypeInternal _addr_default_instance_;
class addr_peer_details;
struct addr_peer_detailsDefaultTypeInternal;
extern addr_peer_detailsDefaultTypeInternal _addr_peer_details_default_instance_;
class all_active_votings_for_voter;
struct all_active_votings_for_voterDefaultTypeInternal;
extern all_active_votings_for_voterDefaultTypeInternal _all_active_votings_for_voter_default_instance_;
class all_finished_votings_for_voter;
struct all_finished_votings_for_voterDefaultTypeInternal;
extern all_finished_votings_for_voterDefaultTypeInternal _all_finished_votings_for_voter_default_instance_;
class amount_on_pkh;
struct amount_on_pkhDefaultTypeInternal;
extern amount_on_pkhDefaultTypeInternal _amount_on_pkh_default_instance_;
class authorization_txid;
struct authorization_txidDefaultTypeInternal;
extern authorization_txidDefaultTypeInternal _authorization_txid_default_instance_;
class block;
struct blockDefaultTypeInternal;
extern blockDefaultTypeInternal _block_default_instance_;
class get_all_active_votings_for_voter;
struct get_all_active_votings_for_voterDefaultTypeInternal;
extern get_all_active_votings_for_voterDefaultTypeInternal _get_all_active_votings_for_voter_default_instance_;
class get_all_finished_votings_for_voter;
struct get_all_finished_votings_for_voterDefaultTypeInternal;
extern get_all_finished_votings_for_voterDefaultTypeInternal _get_all_finished_votings_for_voter_default_instance_;
class get_amount_on_pkh;
struct get_amount_on_pkhDefaultTypeInternal;
extern get_amount_on_pkhDefaultTypeInternal _get_amount_on_pkh_default_instance_;
class get_authorization_txid;
struct get_authorization_txidDefaultTypeInternal;
extern get_authorization_txidDefaultTypeInternal _get_authorization_txid_default_instance_;
class get_transaction;
struct get_transactionDefaultTypeInternal;
extern get_transactionDefaultTypeInternal _get_transaction_default_instance_;
class getaddr;
struct getaddrDefaultTypeInternal;
extern getaddrDefaultTypeInternal _getaddr_default_instance_;
class getblock;
struct getblockDefaultTypeInternal;
extern getblockDefaultTypeInternal _getblock_default_instance_;
class getheaders;
struct getheadersDefaultTypeInternal;
extern getheadersDefaultTypeInternal _getheaders_default_instance_;
class getmempooltransactions;
struct getmempooltransactionsDefaultTypeInternal;
extern getmempooltransactionsDefaultTypeInternal _getmempooltransactions_default_instance_;
class getmerklebranch;
struct getmerklebranchDefaultTypeInternal;
extern getmerklebranchDefaultTypeInternal _getmerklebranch_default_instance_;
class gettxs;
struct gettxsDefaultTypeInternal;
extern gettxsDefaultTypeInternal _gettxs_default_instance_;
class header;
struct headerDefaultTypeInternal;
extern headerDefaultTypeInternal _header_default_instance_;
class headers;
struct headersDefaultTypeInternal;
extern headersDefaultTypeInternal _headers_default_instance_;
class merkle_branch;
struct merkle_branchDefaultTypeInternal;
extern merkle_branchDefaultTypeInternal _merkle_branch_default_instance_;
class proto_massage;
struct proto_massageDefaultTypeInternal;
extern proto_massageDefaultTypeInternal _proto_massage_default_instance_;
class request;
struct requestDefaultTypeInternal;
extern requestDefaultTypeInternal _request_default_instance_;
class transaction;
struct transactionDefaultTypeInternal;
extern transactionDefaultTypeInternal _transaction_default_instance_;
class transaction_vin;
struct transaction_vinDefaultTypeInternal;
extern transaction_vinDefaultTypeInternal _transaction_vin_default_instance_;
class transaction_vout;
struct transaction_voutDefaultTypeInternal;
extern transaction_voutDefaultTypeInternal _transaction_vout_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::addr* Arena::CreateMaybeMessage<::proto::addr>(Arena*);
template<> ::proto::addr_peer_details* Arena::CreateMaybeMessage<::proto::addr_peer_details>(Arena*);
template<> ::proto::all_active_votings_for_voter* Arena::CreateMaybeMessage<::proto::all_active_votings_for_voter>(Arena*);
template<> ::proto::all_finished_votings_for_voter* Arena::CreateMaybeMessage<::proto::all_finished_votings_for_voter>(Arena*);
template<> ::proto::amount_on_pkh* Arena::CreateMaybeMessage<::proto::amount_on_pkh>(Arena*);
template<> ::proto::authorization_txid* Arena::CreateMaybeMessage<::proto::authorization_txid>(Arena*);
template<> ::proto::block* Arena::CreateMaybeMessage<::proto::block>(Arena*);
template<> ::proto::get_all_active_votings_for_voter* Arena::CreateMaybeMessage<::proto::get_all_active_votings_for_voter>(Arena*);
template<> ::proto::get_all_finished_votings_for_voter* Arena::CreateMaybeMessage<::proto::get_all_finished_votings_for_voter>(Arena*);
template<> ::proto::get_amount_on_pkh* Arena::CreateMaybeMessage<::proto::get_amount_on_pkh>(Arena*);
template<> ::proto::get_authorization_txid* Arena::CreateMaybeMessage<::proto::get_authorization_txid>(Arena*);
template<> ::proto::get_transaction* Arena::CreateMaybeMessage<::proto::get_transaction>(Arena*);
template<> ::proto::getaddr* Arena::CreateMaybeMessage<::proto::getaddr>(Arena*);
template<> ::proto::getblock* Arena::CreateMaybeMessage<::proto::getblock>(Arena*);
template<> ::proto::getheaders* Arena::CreateMaybeMessage<::proto::getheaders>(Arena*);
template<> ::proto::getmempooltransactions* Arena::CreateMaybeMessage<::proto::getmempooltransactions>(Arena*);
template<> ::proto::getmerklebranch* Arena::CreateMaybeMessage<::proto::getmerklebranch>(Arena*);
template<> ::proto::gettxs* Arena::CreateMaybeMessage<::proto::gettxs>(Arena*);
template<> ::proto::header* Arena::CreateMaybeMessage<::proto::header>(Arena*);
template<> ::proto::headers* Arena::CreateMaybeMessage<::proto::headers>(Arena*);
template<> ::proto::merkle_branch* Arena::CreateMaybeMessage<::proto::merkle_branch>(Arena*);
template<> ::proto::proto_massage* Arena::CreateMaybeMessage<::proto::proto_massage>(Arena*);
template<> ::proto::request* Arena::CreateMaybeMessage<::proto::request>(Arena*);
template<> ::proto::transaction* Arena::CreateMaybeMessage<::proto::transaction>(Arena*);
template<> ::proto::transaction_vin* Arena::CreateMaybeMessage<::proto::transaction_vin>(Arena*);
template<> ::proto::transaction_vout* Arena::CreateMaybeMessage<::proto::transaction_vout>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum transaction_transactiontype : int {
  transaction_transactiontype_add_secret_vote = 0,
  transaction_transactiontype_add_open_vote = 1,
  transaction_transactiontype_generate = 2,
  transaction_transactiontype_authorize_miner = 3,
  transaction_transactiontype_authorize_organizer = 4,
  transaction_transactiontype_authorize_issuer = 5,
  transaction_transactiontype_authorize_voter = 6,
  transaction_transactiontype_create_voting = 7,
  transaction_transactiontype_coin_join = 8,
  transaction_transactiontype_another_voting_protocol = 9,
  transaction_transactiontype_hash_personal_data = 10,
  transaction_transactiontype_transaction_transactiontype_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  transaction_transactiontype_transaction_transactiontype_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool transaction_transactiontype_IsValid(int value);
constexpr transaction_transactiontype transaction_transactiontype_transactiontype_MIN = transaction_transactiontype_add_secret_vote;
constexpr transaction_transactiontype transaction_transactiontype_transactiontype_MAX = transaction_transactiontype_hash_personal_data;
constexpr int transaction_transactiontype_transactiontype_ARRAYSIZE = transaction_transactiontype_transactiontype_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* transaction_transactiontype_descriptor();
template<typename T>
inline const std::string& transaction_transactiontype_Name(T enum_t_value) {
  static_assert(::std::is_same<T, transaction_transactiontype>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function transaction_transactiontype_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    transaction_transactiontype_descriptor(), enum_t_value);
}
inline bool transaction_transactiontype_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, transaction_transactiontype* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<transaction_transactiontype>(
    transaction_transactiontype_descriptor(), name, value);
}
// ===================================================================

class transaction_vin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.transaction.vin) */ {
 public:
  inline transaction_vin() : transaction_vin(nullptr) {}
  ~transaction_vin() override;
  explicit constexpr transaction_vin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  transaction_vin(const transaction_vin& from);
  transaction_vin(transaction_vin&& from) noexcept
    : transaction_vin() {
    *this = ::std::move(from);
  }

  inline transaction_vin& operator=(const transaction_vin& from) {
    CopyFrom(from);
    return *this;
  }
  inline transaction_vin& operator=(transaction_vin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const transaction_vin& default_instance() {
    return *internal_default_instance();
  }
  static inline const transaction_vin* internal_default_instance() {
    return reinterpret_cast<const transaction_vin*>(
               &_transaction_vin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(transaction_vin& a, transaction_vin& b) {
    a.Swap(&b);
  }
  inline void Swap(transaction_vin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(transaction_vin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  transaction_vin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<transaction_vin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const transaction_vin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const transaction_vin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(transaction_vin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.transaction.vin";
  }
  protected:
  explicit transaction_vin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMTxidFieldNumber = 1,
    kMSignFieldNumber = 2,
    kMPkFieldNumber = 3,
  };
  // bytes m_txid = 1;
  void clear_m_txid();
  const std::string& m_txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_txid();
  PROTOBUF_NODISCARD std::string* release_m_txid();
  void set_allocated_m_txid(std::string* m_txid);
  private:
  const std::string& _internal_m_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_txid(const std::string& value);
  std::string* _internal_mutable_m_txid();
  public:

  // optional bytes m_sign = 2;
  bool has_m_sign() const;
  private:
  bool _internal_has_m_sign() const;
  public:
  void clear_m_sign();
  const std::string& m_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_sign();
  PROTOBUF_NODISCARD std::string* release_m_sign();
  void set_allocated_m_sign(std::string* m_sign);
  private:
  const std::string& _internal_m_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_sign(const std::string& value);
  std::string* _internal_mutable_m_sign();
  public:

  // bytes m_pk = 3;
  void clear_m_pk();
  const std::string& m_pk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_pk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_pk();
  PROTOBUF_NODISCARD std::string* release_m_pk();
  void set_allocated_m_pk(std::string* m_pk);
  private:
  const std::string& _internal_m_pk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_pk(const std::string& value);
  std::string* _internal_mutable_m_pk();
  public:

  // @@protoc_insertion_point(class_scope:proto.transaction.vin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_txid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_sign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_pk_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class transaction_vout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.transaction.vout) */ {
 public:
  inline transaction_vout() : transaction_vout(nullptr) {}
  ~transaction_vout() override;
  explicit constexpr transaction_vout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  transaction_vout(const transaction_vout& from);
  transaction_vout(transaction_vout&& from) noexcept
    : transaction_vout() {
    *this = ::std::move(from);
  }

  inline transaction_vout& operator=(const transaction_vout& from) {
    CopyFrom(from);
    return *this;
  }
  inline transaction_vout& operator=(transaction_vout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const transaction_vout& default_instance() {
    return *internal_default_instance();
  }
  static inline const transaction_vout* internal_default_instance() {
    return reinterpret_cast<const transaction_vout*>(
               &_transaction_vout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(transaction_vout& a, transaction_vout& b) {
    a.Swap(&b);
  }
  inline void Swap(transaction_vout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(transaction_vout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  transaction_vout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<transaction_vout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const transaction_vout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const transaction_vout& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(transaction_vout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.transaction.vout";
  }
  protected:
  explicit transaction_vout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMPkhFieldNumber = 1,
    kMAmountFieldNumber = 2,
  };
  // bytes m_pkh = 1;
  void clear_m_pkh();
  const std::string& m_pkh() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_pkh(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_pkh();
  PROTOBUF_NODISCARD std::string* release_m_pkh();
  void set_allocated_m_pkh(std::string* m_pkh);
  private:
  const std::string& _internal_m_pkh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_pkh(const std::string& value);
  std::string* _internal_mutable_m_pkh();
  public:

  // fixed32 m_amount = 2;
  void clear_m_amount();
  uint32_t m_amount() const;
  void set_m_amount(uint32_t value);
  private:
  uint32_t _internal_m_amount() const;
  void _internal_set_m_amount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.transaction.vout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_pkh_;
  uint32_t m_amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.transaction) */ {
 public:
  inline transaction() : transaction(nullptr) {}
  ~transaction() override;
  explicit constexpr transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  transaction(const transaction& from);
  transaction(transaction&& from) noexcept
    : transaction() {
    *this = ::std::move(from);
  }

  inline transaction& operator=(const transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline transaction& operator=(transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const transaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const transaction* internal_default_instance() {
    return reinterpret_cast<const transaction*>(
               &_transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(transaction& a, transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(transaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const transaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const transaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(transaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.transaction";
  }
  protected:
  explicit transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef transaction_vin vin;
  typedef transaction_vout vout;

  typedef transaction_transactiontype transactiontype;
  static constexpr transactiontype add_secret_vote =
    transaction_transactiontype_add_secret_vote;
  static constexpr transactiontype add_open_vote =
    transaction_transactiontype_add_open_vote;
  static constexpr transactiontype generate =
    transaction_transactiontype_generate;
  static constexpr transactiontype authorize_miner =
    transaction_transactiontype_authorize_miner;
  static constexpr transactiontype authorize_organizer =
    transaction_transactiontype_authorize_organizer;
  static constexpr transactiontype authorize_issuer =
    transaction_transactiontype_authorize_issuer;
  static constexpr transactiontype authorize_voter =
    transaction_transactiontype_authorize_voter;
  static constexpr transactiontype create_voting =
    transaction_transactiontype_create_voting;
  static constexpr transactiontype coin_join =
    transaction_transactiontype_coin_join;
  static constexpr transactiontype another_voting_protocol =
    transaction_transactiontype_another_voting_protocol;
  static constexpr transactiontype hash_personal_data =
    transaction_transactiontype_hash_personal_data;
  static inline bool transactiontype_IsValid(int value) {
    return transaction_transactiontype_IsValid(value);
  }
  static constexpr transactiontype transactiontype_MIN =
    transaction_transactiontype_transactiontype_MIN;
  static constexpr transactiontype transactiontype_MAX =
    transaction_transactiontype_transactiontype_MAX;
  static constexpr int transactiontype_ARRAYSIZE =
    transaction_transactiontype_transactiontype_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  transactiontype_descriptor() {
    return transaction_transactiontype_descriptor();
  }
  template<typename T>
  static inline const std::string& transactiontype_Name(T enum_t_value) {
    static_assert(::std::is_same<T, transactiontype>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function transactiontype_Name.");
    return transaction_transactiontype_Name(enum_t_value);
  }
  static inline bool transactiontype_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      transactiontype* value) {
    return transaction_transactiontype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMVinFieldNumber = 2,
    kMVoutFieldNumber = 3,
    kMTxidFieldNumber = 4,
    kMAllmetadataFieldNumber = 5,
    kMTypeFieldNumber = 1,
  };
  // repeated .proto.transaction.vin m_vin = 2;
  int m_vin_size() const;
  private:
  int _internal_m_vin_size() const;
  public:
  void clear_m_vin();
  ::proto::transaction_vin* mutable_m_vin(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vin >*
      mutable_m_vin();
  private:
  const ::proto::transaction_vin& _internal_m_vin(int index) const;
  ::proto::transaction_vin* _internal_add_m_vin();
  public:
  const ::proto::transaction_vin& m_vin(int index) const;
  ::proto::transaction_vin* add_m_vin();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vin >&
      m_vin() const;

  // repeated .proto.transaction.vout m_vout = 3;
  int m_vout_size() const;
  private:
  int _internal_m_vout_size() const;
  public:
  void clear_m_vout();
  ::proto::transaction_vout* mutable_m_vout(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vout >*
      mutable_m_vout();
  private:
  const ::proto::transaction_vout& _internal_m_vout(int index) const;
  ::proto::transaction_vout* _internal_add_m_vout();
  public:
  const ::proto::transaction_vout& m_vout(int index) const;
  ::proto::transaction_vout* add_m_vout();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vout >&
      m_vout() const;

  // bytes m_txid = 4;
  void clear_m_txid();
  const std::string& m_txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_txid();
  PROTOBUF_NODISCARD std::string* release_m_txid();
  void set_allocated_m_txid(std::string* m_txid);
  private:
  const std::string& _internal_m_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_txid(const std::string& value);
  std::string* _internal_mutable_m_txid();
  public:

  // bytes m_allmetadata = 5;
  void clear_m_allmetadata();
  const std::string& m_allmetadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_allmetadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_allmetadata();
  PROTOBUF_NODISCARD std::string* release_m_allmetadata();
  void set_allocated_m_allmetadata(std::string* m_allmetadata);
  private:
  const std::string& _internal_m_allmetadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_allmetadata(const std::string& value);
  std::string* _internal_mutable_m_allmetadata();
  public:

  // .proto.transaction.transactiontype m_type = 1;
  void clear_m_type();
  ::proto::transaction_transactiontype m_type() const;
  void set_m_type(::proto::transaction_transactiontype value);
  private:
  ::proto::transaction_transactiontype _internal_m_type() const;
  void _internal_set_m_type(::proto::transaction_transactiontype value);
  public:

  // @@protoc_insertion_point(class_scope:proto.transaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vin > m_vin_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vout > m_vout_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_txid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_allmetadata_;
  int m_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.header) */ {
 public:
  inline header() : header(nullptr) {}
  ~header() override;
  explicit constexpr header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  header(const header& from);
  header(header&& from) noexcept
    : header() {
    *this = ::std::move(from);
  }

  inline header& operator=(const header& from) {
    CopyFrom(from);
    return *this;
  }
  inline header& operator=(header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const header& default_instance() {
    return *internal_default_instance();
  }
  static inline const header* internal_default_instance() {
    return reinterpret_cast<const header*>(
               &_header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(header& a, header& b) {
    a.Swap(&b);
  }
  inline void Swap(header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const header& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.header";
  }
  protected:
  explicit header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMAllSignaturesFieldNumber = 6,
    kMParentHashFieldNumber = 2,
    kMActualHashFieldNumber = 3,
    kMAllTxHashFieldNumber = 5,
    kMVersionFieldNumber = 1,
    kMBlockTimeFieldNumber = 4,
  };
  // repeated bytes m_all_signatures = 6;
  int m_all_signatures_size() const;
  private:
  int _internal_m_all_signatures_size() const;
  public:
  void clear_m_all_signatures();
  const std::string& m_all_signatures(int index) const;
  std::string* mutable_m_all_signatures(int index);
  void set_m_all_signatures(int index, const std::string& value);
  void set_m_all_signatures(int index, std::string&& value);
  void set_m_all_signatures(int index, const char* value);
  void set_m_all_signatures(int index, const void* value, size_t size);
  std::string* add_m_all_signatures();
  void add_m_all_signatures(const std::string& value);
  void add_m_all_signatures(std::string&& value);
  void add_m_all_signatures(const char* value);
  void add_m_all_signatures(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& m_all_signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_m_all_signatures();
  private:
  const std::string& _internal_m_all_signatures(int index) const;
  std::string* _internal_add_m_all_signatures();
  public:

  // bytes m_parent_hash = 2;
  void clear_m_parent_hash();
  const std::string& m_parent_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_parent_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_parent_hash();
  PROTOBUF_NODISCARD std::string* release_m_parent_hash();
  void set_allocated_m_parent_hash(std::string* m_parent_hash);
  private:
  const std::string& _internal_m_parent_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_parent_hash(const std::string& value);
  std::string* _internal_mutable_m_parent_hash();
  public:

  // bytes m_actual_hash = 3;
  void clear_m_actual_hash();
  const std::string& m_actual_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_actual_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_actual_hash();
  PROTOBUF_NODISCARD std::string* release_m_actual_hash();
  void set_allocated_m_actual_hash(std::string* m_actual_hash);
  private:
  const std::string& _internal_m_actual_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_actual_hash(const std::string& value);
  std::string* _internal_mutable_m_actual_hash();
  public:

  // bytes m_all_tx_hash = 5;
  void clear_m_all_tx_hash();
  const std::string& m_all_tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_all_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_all_tx_hash();
  PROTOBUF_NODISCARD std::string* release_m_all_tx_hash();
  void set_allocated_m_all_tx_hash(std::string* m_all_tx_hash);
  private:
  const std::string& _internal_m_all_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_all_tx_hash(const std::string& value);
  std::string* _internal_mutable_m_all_tx_hash();
  public:

  // fixed32 m_version = 1;
  void clear_m_version();
  uint32_t m_version() const;
  void set_m_version(uint32_t value);
  private:
  uint32_t _internal_m_version() const;
  void _internal_set_m_version(uint32_t value);
  public:

  // fixed32 m_block_time = 4;
  void clear_m_block_time();
  uint32_t m_block_time() const;
  void set_m_block_time(uint32_t value);
  private:
  uint32_t _internal_m_block_time() const;
  void _internal_set_m_block_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> m_all_signatures_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_parent_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_actual_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_all_tx_hash_;
  uint32_t m_version_;
  uint32_t m_block_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class headers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.headers) */ {
 public:
  inline headers() : headers(nullptr) {}
  ~headers() override;
  explicit constexpr headers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  headers(const headers& from);
  headers(headers&& from) noexcept
    : headers() {
    *this = ::std::move(from);
  }

  inline headers& operator=(const headers& from) {
    CopyFrom(from);
    return *this;
  }
  inline headers& operator=(headers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const headers& default_instance() {
    return *internal_default_instance();
  }
  static inline const headers* internal_default_instance() {
    return reinterpret_cast<const headers*>(
               &_headers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(headers& a, headers& b) {
    a.Swap(&b);
  }
  inline void Swap(headers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(headers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  headers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<headers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const headers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const headers& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(headers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.headers";
  }
  protected:
  explicit headers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMHeadersFieldNumber = 1,
  };
  // repeated .proto.header m_headers = 1;
  int m_headers_size() const;
  private:
  int _internal_m_headers_size() const;
  public:
  void clear_m_headers();
  ::proto::header* mutable_m_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::header >*
      mutable_m_headers();
  private:
  const ::proto::header& _internal_m_headers(int index) const;
  ::proto::header* _internal_add_m_headers();
  public:
  const ::proto::header& m_headers(int index) const;
  ::proto::header* add_m_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::header >&
      m_headers() const;

  // @@protoc_insertion_point(class_scope:proto.headers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::header > m_headers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class block final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.block) */ {
 public:
  inline block() : block(nullptr) {}
  ~block() override;
  explicit constexpr block(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  block(const block& from);
  block(block&& from) noexcept
    : block() {
    *this = ::std::move(from);
  }

  inline block& operator=(const block& from) {
    CopyFrom(from);
    return *this;
  }
  inline block& operator=(block&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const block& default_instance() {
    return *internal_default_instance();
  }
  static inline const block* internal_default_instance() {
    return reinterpret_cast<const block*>(
               &_block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(block& a, block& b) {
    a.Swap(&b);
  }
  inline void Swap(block* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<block>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const block& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const block& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(block* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.block";
  }
  protected:
  explicit block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMTransactionFieldNumber = 2,
    kMHeaderFieldNumber = 1,
  };
  // repeated .proto.transaction m_transaction = 2;
  int m_transaction_size() const;
  private:
  int _internal_m_transaction_size() const;
  public:
  void clear_m_transaction();
  ::proto::transaction* mutable_m_transaction(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction >*
      mutable_m_transaction();
  private:
  const ::proto::transaction& _internal_m_transaction(int index) const;
  ::proto::transaction* _internal_add_m_transaction();
  public:
  const ::proto::transaction& m_transaction(int index) const;
  ::proto::transaction* add_m_transaction();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction >&
      m_transaction() const;

  // .proto.header m_header = 1;
  bool has_m_header() const;
  private:
  bool _internal_has_m_header() const;
  public:
  void clear_m_header();
  const ::proto::header& m_header() const;
  PROTOBUF_NODISCARD ::proto::header* release_m_header();
  ::proto::header* mutable_m_header();
  void set_allocated_m_header(::proto::header* m_header);
  private:
  const ::proto::header& _internal_m_header() const;
  ::proto::header* _internal_mutable_m_header();
  public:
  void unsafe_arena_set_allocated_m_header(
      ::proto::header* m_header);
  ::proto::header* unsafe_arena_release_m_header();

  // @@protoc_insertion_point(class_scope:proto.block)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction > m_transaction_;
  ::proto::header* m_header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class addr_peer_details final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.addr.peer_details) */ {
 public:
  inline addr_peer_details() : addr_peer_details(nullptr) {}
  ~addr_peer_details() override;
  explicit constexpr addr_peer_details(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  addr_peer_details(const addr_peer_details& from);
  addr_peer_details(addr_peer_details&& from) noexcept
    : addr_peer_details() {
    *this = ::std::move(from);
  }

  inline addr_peer_details& operator=(const addr_peer_details& from) {
    CopyFrom(from);
    return *this;
  }
  inline addr_peer_details& operator=(addr_peer_details&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const addr_peer_details& default_instance() {
    return *internal_default_instance();
  }
  static inline const addr_peer_details* internal_default_instance() {
    return reinterpret_cast<const addr_peer_details*>(
               &_addr_peer_details_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(addr_peer_details& a, addr_peer_details& b) {
    a.Swap(&b);
  }
  inline void Swap(addr_peer_details* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(addr_peer_details* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  addr_peer_details* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<addr_peer_details>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const addr_peer_details& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const addr_peer_details& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(addr_peer_details* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.addr.peer_details";
  }
  protected:
  explicit addr_peer_details(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMAddressFieldNumber = 1,
    kMTimestampFieldNumber = 3,
    kMPortFieldNumber = 2,
  };
  // string m_address = 1;
  void clear_m_address();
  const std::string& m_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_address();
  PROTOBUF_NODISCARD std::string* release_m_address();
  void set_allocated_m_address(std::string* m_address);
  private:
  const std::string& _internal_m_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_address(const std::string& value);
  std::string* _internal_mutable_m_address();
  public:

  // uint64 m_timestamp = 3;
  void clear_m_timestamp();
  uint64_t m_timestamp() const;
  void set_m_timestamp(uint64_t value);
  private:
  uint64_t _internal_m_timestamp() const;
  void _internal_set_m_timestamp(uint64_t value);
  public:

  // uint32 m_port = 2;
  void clear_m_port();
  uint32_t m_port() const;
  void set_m_port(uint32_t value);
  private:
  uint32_t _internal_m_port() const;
  void _internal_set_m_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.addr.peer_details)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_address_;
  uint64_t m_timestamp_;
  uint32_t m_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class addr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.addr) */ {
 public:
  inline addr() : addr(nullptr) {}
  ~addr() override;
  explicit constexpr addr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  addr(const addr& from);
  addr(addr&& from) noexcept
    : addr() {
    *this = ::std::move(from);
  }

  inline addr& operator=(const addr& from) {
    CopyFrom(from);
    return *this;
  }
  inline addr& operator=(addr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const addr& default_instance() {
    return *internal_default_instance();
  }
  static inline const addr* internal_default_instance() {
    return reinterpret_cast<const addr*>(
               &_addr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(addr& a, addr& b) {
    a.Swap(&b);
  }
  inline void Swap(addr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(addr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  addr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<addr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const addr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const addr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(addr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.addr";
  }
  protected:
  explicit addr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef addr_peer_details peer_details;

  // accessors -------------------------------------------------------

  enum : int {
    kMPeerListFieldNumber = 1,
  };
  // repeated .proto.addr.peer_details m_peer_list = 1;
  int m_peer_list_size() const;
  private:
  int _internal_m_peer_list_size() const;
  public:
  void clear_m_peer_list();
  ::proto::addr_peer_details* mutable_m_peer_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::addr_peer_details >*
      mutable_m_peer_list();
  private:
  const ::proto::addr_peer_details& _internal_m_peer_list(int index) const;
  ::proto::addr_peer_details* _internal_add_m_peer_list();
  public:
  const ::proto::addr_peer_details& m_peer_list(int index) const;
  ::proto::addr_peer_details* add_m_peer_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::addr_peer_details >&
      m_peer_list() const;

  // @@protoc_insertion_point(class_scope:proto.addr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::addr_peer_details > m_peer_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class all_active_votings_for_voter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.all_active_votings_for_voter) */ {
 public:
  inline all_active_votings_for_voter() : all_active_votings_for_voter(nullptr) {}
  ~all_active_votings_for_voter() override;
  explicit constexpr all_active_votings_for_voter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  all_active_votings_for_voter(const all_active_votings_for_voter& from);
  all_active_votings_for_voter(all_active_votings_for_voter&& from) noexcept
    : all_active_votings_for_voter() {
    *this = ::std::move(from);
  }

  inline all_active_votings_for_voter& operator=(const all_active_votings_for_voter& from) {
    CopyFrom(from);
    return *this;
  }
  inline all_active_votings_for_voter& operator=(all_active_votings_for_voter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const all_active_votings_for_voter& default_instance() {
    return *internal_default_instance();
  }
  static inline const all_active_votings_for_voter* internal_default_instance() {
    return reinterpret_cast<const all_active_votings_for_voter*>(
               &_all_active_votings_for_voter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(all_active_votings_for_voter& a, all_active_votings_for_voter& b) {
    a.Swap(&b);
  }
  inline void Swap(all_active_votings_for_voter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(all_active_votings_for_voter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  all_active_votings_for_voter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<all_active_votings_for_voter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const all_active_votings_for_voter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const all_active_votings_for_voter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(all_active_votings_for_voter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.all_active_votings_for_voter";
  }
  protected:
  explicit all_active_votings_for_voter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMVotingIdsFieldNumber = 1,
  };
  // repeated bytes m_voting_ids = 1;
  int m_voting_ids_size() const;
  private:
  int _internal_m_voting_ids_size() const;
  public:
  void clear_m_voting_ids();
  const std::string& m_voting_ids(int index) const;
  std::string* mutable_m_voting_ids(int index);
  void set_m_voting_ids(int index, const std::string& value);
  void set_m_voting_ids(int index, std::string&& value);
  void set_m_voting_ids(int index, const char* value);
  void set_m_voting_ids(int index, const void* value, size_t size);
  std::string* add_m_voting_ids();
  void add_m_voting_ids(const std::string& value);
  void add_m_voting_ids(std::string&& value);
  void add_m_voting_ids(const char* value);
  void add_m_voting_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& m_voting_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_m_voting_ids();
  private:
  const std::string& _internal_m_voting_ids(int index) const;
  std::string* _internal_add_m_voting_ids();
  public:

  // @@protoc_insertion_point(class_scope:proto.all_active_votings_for_voter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> m_voting_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class getheaders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.getheaders) */ {
 public:
  inline getheaders() : getheaders(nullptr) {}
  ~getheaders() override;
  explicit constexpr getheaders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getheaders(const getheaders& from);
  getheaders(getheaders&& from) noexcept
    : getheaders() {
    *this = ::std::move(from);
  }

  inline getheaders& operator=(const getheaders& from) {
    CopyFrom(from);
    return *this;
  }
  inline getheaders& operator=(getheaders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getheaders& default_instance() {
    return *internal_default_instance();
  }
  static inline const getheaders* internal_default_instance() {
    return reinterpret_cast<const getheaders*>(
               &_getheaders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(getheaders& a, getheaders& b) {
    a.Swap(&b);
  }
  inline void Swap(getheaders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getheaders* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getheaders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getheaders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getheaders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const getheaders& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getheaders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.getheaders";
  }
  protected:
  explicit getheaders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMHashHeaderStartFieldNumber = 2,
    kMHashHeaderStopFieldNumber = 3,
    kMVersionFieldNumber = 1,
  };
  // bytes m_hash_header_start = 2;
  void clear_m_hash_header_start();
  const std::string& m_hash_header_start() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_hash_header_start(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_hash_header_start();
  PROTOBUF_NODISCARD std::string* release_m_hash_header_start();
  void set_allocated_m_hash_header_start(std::string* m_hash_header_start);
  private:
  const std::string& _internal_m_hash_header_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_hash_header_start(const std::string& value);
  std::string* _internal_mutable_m_hash_header_start();
  public:

  // bytes m_hash_header_stop = 3;
  void clear_m_hash_header_stop();
  const std::string& m_hash_header_stop() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_hash_header_stop(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_hash_header_stop();
  PROTOBUF_NODISCARD std::string* release_m_hash_header_stop();
  void set_allocated_m_hash_header_stop(std::string* m_hash_header_stop);
  private:
  const std::string& _internal_m_hash_header_stop() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_hash_header_stop(const std::string& value);
  std::string* _internal_mutable_m_hash_header_stop();
  public:

  // fixed32 m_version = 1;
  void clear_m_version();
  uint32_t m_version() const;
  void set_m_version(uint32_t value);
  private:
  uint32_t _internal_m_version() const;
  void _internal_set_m_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.getheaders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_hash_header_start_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_hash_header_stop_;
  uint32_t m_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class gettxs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.gettxs) */ {
 public:
  inline gettxs() : gettxs(nullptr) {}
  ~gettxs() override;
  explicit constexpr gettxs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  gettxs(const gettxs& from);
  gettxs(gettxs&& from) noexcept
    : gettxs() {
    *this = ::std::move(from);
  }

  inline gettxs& operator=(const gettxs& from) {
    CopyFrom(from);
    return *this;
  }
  inline gettxs& operator=(gettxs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const gettxs& default_instance() {
    return *internal_default_instance();
  }
  static inline const gettxs* internal_default_instance() {
    return reinterpret_cast<const gettxs*>(
               &_gettxs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(gettxs& a, gettxs& b) {
    a.Swap(&b);
  }
  inline void Swap(gettxs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(gettxs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  gettxs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<gettxs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const gettxs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const gettxs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(gettxs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.gettxs";
  }
  protected:
  explicit gettxs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMHashHeaderFieldNumber = 1,
  };
  // bytes m_hash_header = 1;
  void clear_m_hash_header();
  const std::string& m_hash_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_hash_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_hash_header();
  PROTOBUF_NODISCARD std::string* release_m_hash_header();
  void set_allocated_m_hash_header(std::string* m_hash_header);
  private:
  const std::string& _internal_m_hash_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_hash_header(const std::string& value);
  std::string* _internal_mutable_m_hash_header();
  public:

  // @@protoc_insertion_point(class_scope:proto.gettxs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_hash_header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class getblock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.getblock) */ {
 public:
  inline getblock() : getblock(nullptr) {}
  ~getblock() override;
  explicit constexpr getblock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getblock(const getblock& from);
  getblock(getblock&& from) noexcept
    : getblock() {
    *this = ::std::move(from);
  }

  inline getblock& operator=(const getblock& from) {
    CopyFrom(from);
    return *this;
  }
  inline getblock& operator=(getblock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getblock& default_instance() {
    return *internal_default_instance();
  }
  static inline const getblock* internal_default_instance() {
    return reinterpret_cast<const getblock*>(
               &_getblock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(getblock& a, getblock& b) {
    a.Swap(&b);
  }
  inline void Swap(getblock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getblock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getblock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getblock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getblock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const getblock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getblock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.getblock";
  }
  protected:
  explicit getblock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMHashHeaderFieldNumber = 1,
  };
  // bytes m_hash_header = 1;
  void clear_m_hash_header();
  const std::string& m_hash_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_hash_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_hash_header();
  PROTOBUF_NODISCARD std::string* release_m_hash_header();
  void set_allocated_m_hash_header(std::string* m_hash_header);
  private:
  const std::string& _internal_m_hash_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_hash_header(const std::string& value);
  std::string* _internal_mutable_m_hash_header();
  public:

  // @@protoc_insertion_point(class_scope:proto.getblock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_hash_header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class getmempooltransactions final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.getmempooltransactions) */ {
 public:
  inline getmempooltransactions() : getmempooltransactions(nullptr) {}
  explicit constexpr getmempooltransactions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getmempooltransactions(const getmempooltransactions& from);
  getmempooltransactions(getmempooltransactions&& from) noexcept
    : getmempooltransactions() {
    *this = ::std::move(from);
  }

  inline getmempooltransactions& operator=(const getmempooltransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline getmempooltransactions& operator=(getmempooltransactions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getmempooltransactions& default_instance() {
    return *internal_default_instance();
  }
  static inline const getmempooltransactions* internal_default_instance() {
    return reinterpret_cast<const getmempooltransactions*>(
               &_getmempooltransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(getmempooltransactions& a, getmempooltransactions& b) {
    a.Swap(&b);
  }
  inline void Swap(getmempooltransactions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getmempooltransactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getmempooltransactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getmempooltransactions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const getmempooltransactions& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const getmempooltransactions& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.getmempooltransactions";
  }
  protected:
  explicit getmempooltransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.getmempooltransactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class getaddr final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.getaddr) */ {
 public:
  inline getaddr() : getaddr(nullptr) {}
  explicit constexpr getaddr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getaddr(const getaddr& from);
  getaddr(getaddr&& from) noexcept
    : getaddr() {
    *this = ::std::move(from);
  }

  inline getaddr& operator=(const getaddr& from) {
    CopyFrom(from);
    return *this;
  }
  inline getaddr& operator=(getaddr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getaddr& default_instance() {
    return *internal_default_instance();
  }
  static inline const getaddr* internal_default_instance() {
    return reinterpret_cast<const getaddr*>(
               &_getaddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(getaddr& a, getaddr& b) {
    a.Swap(&b);
  }
  inline void Swap(getaddr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getaddr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getaddr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getaddr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const getaddr& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const getaddr& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.getaddr";
  }
  protected:
  explicit getaddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.getaddr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class getmerklebranch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.getmerklebranch) */ {
 public:
  inline getmerklebranch() : getmerklebranch(nullptr) {}
  ~getmerklebranch() override;
  explicit constexpr getmerklebranch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getmerklebranch(const getmerklebranch& from);
  getmerklebranch(getmerklebranch&& from) noexcept
    : getmerklebranch() {
    *this = ::std::move(from);
  }

  inline getmerklebranch& operator=(const getmerklebranch& from) {
    CopyFrom(from);
    return *this;
  }
  inline getmerklebranch& operator=(getmerklebranch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getmerklebranch& default_instance() {
    return *internal_default_instance();
  }
  static inline const getmerklebranch* internal_default_instance() {
    return reinterpret_cast<const getmerklebranch*>(
               &_getmerklebranch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(getmerklebranch& a, getmerklebranch& b) {
    a.Swap(&b);
  }
  inline void Swap(getmerklebranch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getmerklebranch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getmerklebranch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getmerklebranch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getmerklebranch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const getmerklebranch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getmerklebranch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.getmerklebranch";
  }
  protected:
  explicit getmerklebranch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMTxidFieldNumber = 1,
  };
  // bytes m_txid = 1;
  void clear_m_txid();
  const std::string& m_txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_txid();
  PROTOBUF_NODISCARD std::string* release_m_txid();
  void set_allocated_m_txid(std::string* m_txid);
  private:
  const std::string& _internal_m_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_txid(const std::string& value);
  std::string* _internal_mutable_m_txid();
  public:

  // @@protoc_insertion_point(class_scope:proto.getmerklebranch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_txid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class merkle_branch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.merkle_branch) */ {
 public:
  inline merkle_branch() : merkle_branch(nullptr) {}
  ~merkle_branch() override;
  explicit constexpr merkle_branch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  merkle_branch(const merkle_branch& from);
  merkle_branch(merkle_branch&& from) noexcept
    : merkle_branch() {
    *this = ::std::move(from);
  }

  inline merkle_branch& operator=(const merkle_branch& from) {
    CopyFrom(from);
    return *this;
  }
  inline merkle_branch& operator=(merkle_branch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const merkle_branch& default_instance() {
    return *internal_default_instance();
  }
  static inline const merkle_branch* internal_default_instance() {
    return reinterpret_cast<const merkle_branch*>(
               &_merkle_branch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(merkle_branch& a, merkle_branch& b) {
    a.Swap(&b);
  }
  inline void Swap(merkle_branch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(merkle_branch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  merkle_branch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<merkle_branch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const merkle_branch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const merkle_branch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(merkle_branch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.merkle_branch";
  }
  protected:
  explicit merkle_branch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMMerkleBranchFieldNumber = 1,
    kMBlockIdFieldNumber = 2,
  };
  // repeated bytes m_merkle_branch = 1;
  int m_merkle_branch_size() const;
  private:
  int _internal_m_merkle_branch_size() const;
  public:
  void clear_m_merkle_branch();
  const std::string& m_merkle_branch(int index) const;
  std::string* mutable_m_merkle_branch(int index);
  void set_m_merkle_branch(int index, const std::string& value);
  void set_m_merkle_branch(int index, std::string&& value);
  void set_m_merkle_branch(int index, const char* value);
  void set_m_merkle_branch(int index, const void* value, size_t size);
  std::string* add_m_merkle_branch();
  void add_m_merkle_branch(const std::string& value);
  void add_m_merkle_branch(std::string&& value);
  void add_m_merkle_branch(const char* value);
  void add_m_merkle_branch(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& m_merkle_branch() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_m_merkle_branch();
  private:
  const std::string& _internal_m_merkle_branch(int index) const;
  std::string* _internal_add_m_merkle_branch();
  public:

  // optional bytes m_block_id = 2;
  bool has_m_block_id() const;
  private:
  bool _internal_has_m_block_id() const;
  public:
  void clear_m_block_id();
  const std::string& m_block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_block_id();
  PROTOBUF_NODISCARD std::string* release_m_block_id();
  void set_allocated_m_block_id(std::string* m_block_id);
  private:
  const std::string& _internal_m_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_block_id(const std::string& value);
  std::string* _internal_mutable_m_block_id();
  public:

  // @@protoc_insertion_point(class_scope:proto.merkle_branch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> m_merkle_branch_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_block_id_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class get_all_active_votings_for_voter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.get_all_active_votings_for_voter) */ {
 public:
  inline get_all_active_votings_for_voter() : get_all_active_votings_for_voter(nullptr) {}
  ~get_all_active_votings_for_voter() override;
  explicit constexpr get_all_active_votings_for_voter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_all_active_votings_for_voter(const get_all_active_votings_for_voter& from);
  get_all_active_votings_for_voter(get_all_active_votings_for_voter&& from) noexcept
    : get_all_active_votings_for_voter() {
    *this = ::std::move(from);
  }

  inline get_all_active_votings_for_voter& operator=(const get_all_active_votings_for_voter& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_all_active_votings_for_voter& operator=(get_all_active_votings_for_voter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_all_active_votings_for_voter& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_all_active_votings_for_voter* internal_default_instance() {
    return reinterpret_cast<const get_all_active_votings_for_voter*>(
               &_get_all_active_votings_for_voter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(get_all_active_votings_for_voter& a, get_all_active_votings_for_voter& b) {
    a.Swap(&b);
  }
  inline void Swap(get_all_active_votings_for_voter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_all_active_votings_for_voter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  get_all_active_votings_for_voter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<get_all_active_votings_for_voter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_all_active_votings_for_voter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_all_active_votings_for_voter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_all_active_votings_for_voter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.get_all_active_votings_for_voter";
  }
  protected:
  explicit get_all_active_votings_for_voter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMVoterPkFieldNumber = 1,
  };
  // bytes m_voter_pk = 1;
  void clear_m_voter_pk();
  const std::string& m_voter_pk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_voter_pk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_voter_pk();
  PROTOBUF_NODISCARD std::string* release_m_voter_pk();
  void set_allocated_m_voter_pk(std::string* m_voter_pk);
  private:
  const std::string& _internal_m_voter_pk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_voter_pk(const std::string& value);
  std::string* _internal_mutable_m_voter_pk();
  public:

  // @@protoc_insertion_point(class_scope:proto.get_all_active_votings_for_voter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_voter_pk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class get_amount_on_pkh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.get_amount_on_pkh) */ {
 public:
  inline get_amount_on_pkh() : get_amount_on_pkh(nullptr) {}
  ~get_amount_on_pkh() override;
  explicit constexpr get_amount_on_pkh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_amount_on_pkh(const get_amount_on_pkh& from);
  get_amount_on_pkh(get_amount_on_pkh&& from) noexcept
    : get_amount_on_pkh() {
    *this = ::std::move(from);
  }

  inline get_amount_on_pkh& operator=(const get_amount_on_pkh& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_amount_on_pkh& operator=(get_amount_on_pkh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_amount_on_pkh& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_amount_on_pkh* internal_default_instance() {
    return reinterpret_cast<const get_amount_on_pkh*>(
               &_get_amount_on_pkh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(get_amount_on_pkh& a, get_amount_on_pkh& b) {
    a.Swap(&b);
  }
  inline void Swap(get_amount_on_pkh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_amount_on_pkh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  get_amount_on_pkh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<get_amount_on_pkh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_amount_on_pkh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_amount_on_pkh& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_amount_on_pkh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.get_amount_on_pkh";
  }
  protected:
  explicit get_amount_on_pkh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMPkhFieldNumber = 1,
  };
  // bytes m_pkh = 1;
  void clear_m_pkh();
  const std::string& m_pkh() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_pkh(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_pkh();
  PROTOBUF_NODISCARD std::string* release_m_pkh();
  void set_allocated_m_pkh(std::string* m_pkh);
  private:
  const std::string& _internal_m_pkh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_pkh(const std::string& value);
  std::string* _internal_mutable_m_pkh();
  public:

  // @@protoc_insertion_point(class_scope:proto.get_amount_on_pkh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_pkh_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class amount_on_pkh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.amount_on_pkh) */ {
 public:
  inline amount_on_pkh() : amount_on_pkh(nullptr) {}
  ~amount_on_pkh() override;
  explicit constexpr amount_on_pkh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  amount_on_pkh(const amount_on_pkh& from);
  amount_on_pkh(amount_on_pkh&& from) noexcept
    : amount_on_pkh() {
    *this = ::std::move(from);
  }

  inline amount_on_pkh& operator=(const amount_on_pkh& from) {
    CopyFrom(from);
    return *this;
  }
  inline amount_on_pkh& operator=(amount_on_pkh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const amount_on_pkh& default_instance() {
    return *internal_default_instance();
  }
  static inline const amount_on_pkh* internal_default_instance() {
    return reinterpret_cast<const amount_on_pkh*>(
               &_amount_on_pkh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(amount_on_pkh& a, amount_on_pkh& b) {
    a.Swap(&b);
  }
  inline void Swap(amount_on_pkh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(amount_on_pkh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  amount_on_pkh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<amount_on_pkh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const amount_on_pkh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const amount_on_pkh& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(amount_on_pkh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.amount_on_pkh";
  }
  protected:
  explicit amount_on_pkh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMTxidFieldNumber = 2,
    kMAmountFieldNumber = 1,
  };
  // optional bytes m_txid = 2;
  bool has_m_txid() const;
  private:
  bool _internal_has_m_txid() const;
  public:
  void clear_m_txid();
  const std::string& m_txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_txid();
  PROTOBUF_NODISCARD std::string* release_m_txid();
  void set_allocated_m_txid(std::string* m_txid);
  private:
  const std::string& _internal_m_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_txid(const std::string& value);
  std::string* _internal_mutable_m_txid();
  public:

  // uint32 m_amount = 1;
  void clear_m_amount();
  uint32_t m_amount() const;
  void set_m_amount(uint32_t value);
  private:
  uint32_t _internal_m_amount() const;
  void _internal_set_m_amount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.amount_on_pkh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_txid_;
  uint32_t m_amount_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class get_transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.get_transaction) */ {
 public:
  inline get_transaction() : get_transaction(nullptr) {}
  ~get_transaction() override;
  explicit constexpr get_transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction(const get_transaction& from);
  get_transaction(get_transaction&& from) noexcept
    : get_transaction() {
    *this = ::std::move(from);
  }

  inline get_transaction& operator=(const get_transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction& operator=(get_transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction* internal_default_instance() {
    return reinterpret_cast<const get_transaction*>(
               &_get_transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(get_transaction& a, get_transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  get_transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<get_transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.get_transaction";
  }
  protected:
  explicit get_transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMTxidFieldNumber = 1,
  };
  // bytes m_txid = 1;
  void clear_m_txid();
  const std::string& m_txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_txid();
  PROTOBUF_NODISCARD std::string* release_m_txid();
  void set_allocated_m_txid(std::string* m_txid);
  private:
  const std::string& _internal_m_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_txid(const std::string& value);
  std::string* _internal_mutable_m_txid();
  public:

  // @@protoc_insertion_point(class_scope:proto.get_transaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_txid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class get_authorization_txid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.get_authorization_txid) */ {
 public:
  inline get_authorization_txid() : get_authorization_txid(nullptr) {}
  ~get_authorization_txid() override;
  explicit constexpr get_authorization_txid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_authorization_txid(const get_authorization_txid& from);
  get_authorization_txid(get_authorization_txid&& from) noexcept
    : get_authorization_txid() {
    *this = ::std::move(from);
  }

  inline get_authorization_txid& operator=(const get_authorization_txid& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_authorization_txid& operator=(get_authorization_txid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_authorization_txid& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_authorization_txid* internal_default_instance() {
    return reinterpret_cast<const get_authorization_txid*>(
               &_get_authorization_txid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(get_authorization_txid& a, get_authorization_txid& b) {
    a.Swap(&b);
  }
  inline void Swap(get_authorization_txid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_authorization_txid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  get_authorization_txid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<get_authorization_txid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_authorization_txid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_authorization_txid& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_authorization_txid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.get_authorization_txid";
  }
  protected:
  explicit get_authorization_txid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMPkFieldNumber = 1,
    kMVotingIdFieldNumber = 2,
  };
  // bytes m_pk = 1;
  void clear_m_pk();
  const std::string& m_pk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_pk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_pk();
  PROTOBUF_NODISCARD std::string* release_m_pk();
  void set_allocated_m_pk(std::string* m_pk);
  private:
  const std::string& _internal_m_pk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_pk(const std::string& value);
  std::string* _internal_mutable_m_pk();
  public:

  // bytes m_voting_id = 2;
  void clear_m_voting_id();
  const std::string& m_voting_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_voting_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_voting_id();
  PROTOBUF_NODISCARD std::string* release_m_voting_id();
  void set_allocated_m_voting_id(std::string* m_voting_id);
  private:
  const std::string& _internal_m_voting_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_voting_id(const std::string& value);
  std::string* _internal_mutable_m_voting_id();
  public:

  // @@protoc_insertion_point(class_scope:proto.get_authorization_txid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_pk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_voting_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class authorization_txid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.authorization_txid) */ {
 public:
  inline authorization_txid() : authorization_txid(nullptr) {}
  ~authorization_txid() override;
  explicit constexpr authorization_txid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  authorization_txid(const authorization_txid& from);
  authorization_txid(authorization_txid&& from) noexcept
    : authorization_txid() {
    *this = ::std::move(from);
  }

  inline authorization_txid& operator=(const authorization_txid& from) {
    CopyFrom(from);
    return *this;
  }
  inline authorization_txid& operator=(authorization_txid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const authorization_txid& default_instance() {
    return *internal_default_instance();
  }
  static inline const authorization_txid* internal_default_instance() {
    return reinterpret_cast<const authorization_txid*>(
               &_authorization_txid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(authorization_txid& a, authorization_txid& b) {
    a.Swap(&b);
  }
  inline void Swap(authorization_txid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(authorization_txid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  authorization_txid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<authorization_txid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const authorization_txid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const authorization_txid& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(authorization_txid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.authorization_txid";
  }
  protected:
  explicit authorization_txid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMTxidFieldNumber = 1,
  };
  // bytes m_txid = 1;
  void clear_m_txid();
  const std::string& m_txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_txid();
  PROTOBUF_NODISCARD std::string* release_m_txid();
  void set_allocated_m_txid(std::string* m_txid);
  private:
  const std::string& _internal_m_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_txid(const std::string& value);
  std::string* _internal_mutable_m_txid();
  public:

  // @@protoc_insertion_point(class_scope:proto.authorization_txid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_txid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class get_all_finished_votings_for_voter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.get_all_finished_votings_for_voter) */ {
 public:
  inline get_all_finished_votings_for_voter() : get_all_finished_votings_for_voter(nullptr) {}
  ~get_all_finished_votings_for_voter() override;
  explicit constexpr get_all_finished_votings_for_voter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_all_finished_votings_for_voter(const get_all_finished_votings_for_voter& from);
  get_all_finished_votings_for_voter(get_all_finished_votings_for_voter&& from) noexcept
    : get_all_finished_votings_for_voter() {
    *this = ::std::move(from);
  }

  inline get_all_finished_votings_for_voter& operator=(const get_all_finished_votings_for_voter& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_all_finished_votings_for_voter& operator=(get_all_finished_votings_for_voter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_all_finished_votings_for_voter& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_all_finished_votings_for_voter* internal_default_instance() {
    return reinterpret_cast<const get_all_finished_votings_for_voter*>(
               &_get_all_finished_votings_for_voter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(get_all_finished_votings_for_voter& a, get_all_finished_votings_for_voter& b) {
    a.Swap(&b);
  }
  inline void Swap(get_all_finished_votings_for_voter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_all_finished_votings_for_voter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  get_all_finished_votings_for_voter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<get_all_finished_votings_for_voter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_all_finished_votings_for_voter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_all_finished_votings_for_voter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_all_finished_votings_for_voter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.get_all_finished_votings_for_voter";
  }
  protected:
  explicit get_all_finished_votings_for_voter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMVoterPkFieldNumber = 1,
  };
  // bytes m_voter_pk = 1;
  void clear_m_voter_pk();
  const std::string& m_voter_pk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_voter_pk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_voter_pk();
  PROTOBUF_NODISCARD std::string* release_m_voter_pk();
  void set_allocated_m_voter_pk(std::string* m_voter_pk);
  private:
  const std::string& _internal_m_voter_pk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_voter_pk(const std::string& value);
  std::string* _internal_mutable_m_voter_pk();
  public:

  // @@protoc_insertion_point(class_scope:proto.get_all_finished_votings_for_voter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_voter_pk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class all_finished_votings_for_voter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.all_finished_votings_for_voter) */ {
 public:
  inline all_finished_votings_for_voter() : all_finished_votings_for_voter(nullptr) {}
  ~all_finished_votings_for_voter() override;
  explicit constexpr all_finished_votings_for_voter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  all_finished_votings_for_voter(const all_finished_votings_for_voter& from);
  all_finished_votings_for_voter(all_finished_votings_for_voter&& from) noexcept
    : all_finished_votings_for_voter() {
    *this = ::std::move(from);
  }

  inline all_finished_votings_for_voter& operator=(const all_finished_votings_for_voter& from) {
    CopyFrom(from);
    return *this;
  }
  inline all_finished_votings_for_voter& operator=(all_finished_votings_for_voter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const all_finished_votings_for_voter& default_instance() {
    return *internal_default_instance();
  }
  static inline const all_finished_votings_for_voter* internal_default_instance() {
    return reinterpret_cast<const all_finished_votings_for_voter*>(
               &_all_finished_votings_for_voter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(all_finished_votings_for_voter& a, all_finished_votings_for_voter& b) {
    a.Swap(&b);
  }
  inline void Swap(all_finished_votings_for_voter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(all_finished_votings_for_voter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  all_finished_votings_for_voter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<all_finished_votings_for_voter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const all_finished_votings_for_voter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const all_finished_votings_for_voter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(all_finished_votings_for_voter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.all_finished_votings_for_voter";
  }
  protected:
  explicit all_finished_votings_for_voter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMVotingIdsFieldNumber = 1,
  };
  // repeated bytes m_voting_ids = 1;
  int m_voting_ids_size() const;
  private:
  int _internal_m_voting_ids_size() const;
  public:
  void clear_m_voting_ids();
  const std::string& m_voting_ids(int index) const;
  std::string* mutable_m_voting_ids(int index);
  void set_m_voting_ids(int index, const std::string& value);
  void set_m_voting_ids(int index, std::string&& value);
  void set_m_voting_ids(int index, const char* value);
  void set_m_voting_ids(int index, const void* value, size_t size);
  std::string* add_m_voting_ids();
  void add_m_voting_ids(const std::string& value);
  void add_m_voting_ids(std::string&& value);
  void add_m_voting_ids(const char* value);
  void add_m_voting_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& m_voting_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_m_voting_ids();
  private:
  const std::string& _internal_m_voting_ids(int index) const;
  std::string* _internal_add_m_voting_ids();
  public:

  // @@protoc_insertion_point(class_scope:proto.all_finished_votings_for_voter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> m_voting_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.request) */ {
 public:
  inline request() : request(nullptr) {}
  ~request() override;
  explicit constexpr request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  request(const request& from);
  request(request&& from) noexcept
    : request() {
    *this = ::std::move(from);
  }

  inline request& operator=(const request& from) {
    CopyFrom(from);
    return *this;
  }
  inline request& operator=(request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const request& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kMGetheaders = 1,
    kMGettxs = 2,
    kMGetblock = 3,
    kMGetmempooltransactions = 4,
    kMGetaddr = 5,
    kMGetmerklebranch = 6,
    kMGetAllActiveVotingsForVoter = 8,
    kMGetAmountOnPkh = 9,
    kMGetTransaction = 10,
    kMGetAuthorizationTxid = 11,
    kMGetAllFinishedVotingsForVoter = 12,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const request* internal_default_instance() {
    return reinterpret_cast<const request*>(
               &_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(request& a, request& b) {
    a.Swap(&b);
  }
  inline void Swap(request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.request";
  }
  protected:
  explicit request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMGetheadersFieldNumber = 1,
    kMGettxsFieldNumber = 2,
    kMGetblockFieldNumber = 3,
    kMGetmempooltransactionsFieldNumber = 4,
    kMGetaddrFieldNumber = 5,
    kMGetmerklebranchFieldNumber = 6,
    kMGetAllActiveVotingsForVoterFieldNumber = 8,
    kMGetAmountOnPkhFieldNumber = 9,
    kMGetTransactionFieldNumber = 10,
    kMGetAuthorizationTxidFieldNumber = 11,
    kMGetAllFinishedVotingsForVoterFieldNumber = 12,
  };
  // .proto.getheaders m_getheaders = 1;
  bool has_m_getheaders() const;
  private:
  bool _internal_has_m_getheaders() const;
  public:
  void clear_m_getheaders();
  const ::proto::getheaders& m_getheaders() const;
  PROTOBUF_NODISCARD ::proto::getheaders* release_m_getheaders();
  ::proto::getheaders* mutable_m_getheaders();
  void set_allocated_m_getheaders(::proto::getheaders* m_getheaders);
  private:
  const ::proto::getheaders& _internal_m_getheaders() const;
  ::proto::getheaders* _internal_mutable_m_getheaders();
  public:
  void unsafe_arena_set_allocated_m_getheaders(
      ::proto::getheaders* m_getheaders);
  ::proto::getheaders* unsafe_arena_release_m_getheaders();

  // .proto.gettxs m_gettxs = 2;
  bool has_m_gettxs() const;
  private:
  bool _internal_has_m_gettxs() const;
  public:
  void clear_m_gettxs();
  const ::proto::gettxs& m_gettxs() const;
  PROTOBUF_NODISCARD ::proto::gettxs* release_m_gettxs();
  ::proto::gettxs* mutable_m_gettxs();
  void set_allocated_m_gettxs(::proto::gettxs* m_gettxs);
  private:
  const ::proto::gettxs& _internal_m_gettxs() const;
  ::proto::gettxs* _internal_mutable_m_gettxs();
  public:
  void unsafe_arena_set_allocated_m_gettxs(
      ::proto::gettxs* m_gettxs);
  ::proto::gettxs* unsafe_arena_release_m_gettxs();

  // .proto.getblock m_getblock = 3;
  bool has_m_getblock() const;
  private:
  bool _internal_has_m_getblock() const;
  public:
  void clear_m_getblock();
  const ::proto::getblock& m_getblock() const;
  PROTOBUF_NODISCARD ::proto::getblock* release_m_getblock();
  ::proto::getblock* mutable_m_getblock();
  void set_allocated_m_getblock(::proto::getblock* m_getblock);
  private:
  const ::proto::getblock& _internal_m_getblock() const;
  ::proto::getblock* _internal_mutable_m_getblock();
  public:
  void unsafe_arena_set_allocated_m_getblock(
      ::proto::getblock* m_getblock);
  ::proto::getblock* unsafe_arena_release_m_getblock();

  // .proto.getmempooltransactions m_getmempooltransactions = 4;
  bool has_m_getmempooltransactions() const;
  private:
  bool _internal_has_m_getmempooltransactions() const;
  public:
  void clear_m_getmempooltransactions();
  const ::proto::getmempooltransactions& m_getmempooltransactions() const;
  PROTOBUF_NODISCARD ::proto::getmempooltransactions* release_m_getmempooltransactions();
  ::proto::getmempooltransactions* mutable_m_getmempooltransactions();
  void set_allocated_m_getmempooltransactions(::proto::getmempooltransactions* m_getmempooltransactions);
  private:
  const ::proto::getmempooltransactions& _internal_m_getmempooltransactions() const;
  ::proto::getmempooltransactions* _internal_mutable_m_getmempooltransactions();
  public:
  void unsafe_arena_set_allocated_m_getmempooltransactions(
      ::proto::getmempooltransactions* m_getmempooltransactions);
  ::proto::getmempooltransactions* unsafe_arena_release_m_getmempooltransactions();

  // .proto.getaddr m_getaddr = 5;
  bool has_m_getaddr() const;
  private:
  bool _internal_has_m_getaddr() const;
  public:
  void clear_m_getaddr();
  const ::proto::getaddr& m_getaddr() const;
  PROTOBUF_NODISCARD ::proto::getaddr* release_m_getaddr();
  ::proto::getaddr* mutable_m_getaddr();
  void set_allocated_m_getaddr(::proto::getaddr* m_getaddr);
  private:
  const ::proto::getaddr& _internal_m_getaddr() const;
  ::proto::getaddr* _internal_mutable_m_getaddr();
  public:
  void unsafe_arena_set_allocated_m_getaddr(
      ::proto::getaddr* m_getaddr);
  ::proto::getaddr* unsafe_arena_release_m_getaddr();

  // .proto.getmerklebranch m_getmerklebranch = 6;
  bool has_m_getmerklebranch() const;
  private:
  bool _internal_has_m_getmerklebranch() const;
  public:
  void clear_m_getmerklebranch();
  const ::proto::getmerklebranch& m_getmerklebranch() const;
  PROTOBUF_NODISCARD ::proto::getmerklebranch* release_m_getmerklebranch();
  ::proto::getmerklebranch* mutable_m_getmerklebranch();
  void set_allocated_m_getmerklebranch(::proto::getmerklebranch* m_getmerklebranch);
  private:
  const ::proto::getmerklebranch& _internal_m_getmerklebranch() const;
  ::proto::getmerklebranch* _internal_mutable_m_getmerklebranch();
  public:
  void unsafe_arena_set_allocated_m_getmerklebranch(
      ::proto::getmerklebranch* m_getmerklebranch);
  ::proto::getmerklebranch* unsafe_arena_release_m_getmerklebranch();

  // .proto.get_all_active_votings_for_voter m_get_all_active_votings_for_voter = 8;
  bool has_m_get_all_active_votings_for_voter() const;
  private:
  bool _internal_has_m_get_all_active_votings_for_voter() const;
  public:
  void clear_m_get_all_active_votings_for_voter();
  const ::proto::get_all_active_votings_for_voter& m_get_all_active_votings_for_voter() const;
  PROTOBUF_NODISCARD ::proto::get_all_active_votings_for_voter* release_m_get_all_active_votings_for_voter();
  ::proto::get_all_active_votings_for_voter* mutable_m_get_all_active_votings_for_voter();
  void set_allocated_m_get_all_active_votings_for_voter(::proto::get_all_active_votings_for_voter* m_get_all_active_votings_for_voter);
  private:
  const ::proto::get_all_active_votings_for_voter& _internal_m_get_all_active_votings_for_voter() const;
  ::proto::get_all_active_votings_for_voter* _internal_mutable_m_get_all_active_votings_for_voter();
  public:
  void unsafe_arena_set_allocated_m_get_all_active_votings_for_voter(
      ::proto::get_all_active_votings_for_voter* m_get_all_active_votings_for_voter);
  ::proto::get_all_active_votings_for_voter* unsafe_arena_release_m_get_all_active_votings_for_voter();

  // .proto.get_amount_on_pkh m_get_amount_on_pkh = 9;
  bool has_m_get_amount_on_pkh() const;
  private:
  bool _internal_has_m_get_amount_on_pkh() const;
  public:
  void clear_m_get_amount_on_pkh();
  const ::proto::get_amount_on_pkh& m_get_amount_on_pkh() const;
  PROTOBUF_NODISCARD ::proto::get_amount_on_pkh* release_m_get_amount_on_pkh();
  ::proto::get_amount_on_pkh* mutable_m_get_amount_on_pkh();
  void set_allocated_m_get_amount_on_pkh(::proto::get_amount_on_pkh* m_get_amount_on_pkh);
  private:
  const ::proto::get_amount_on_pkh& _internal_m_get_amount_on_pkh() const;
  ::proto::get_amount_on_pkh* _internal_mutable_m_get_amount_on_pkh();
  public:
  void unsafe_arena_set_allocated_m_get_amount_on_pkh(
      ::proto::get_amount_on_pkh* m_get_amount_on_pkh);
  ::proto::get_amount_on_pkh* unsafe_arena_release_m_get_amount_on_pkh();

  // .proto.get_transaction m_get_transaction = 10;
  bool has_m_get_transaction() const;
  private:
  bool _internal_has_m_get_transaction() const;
  public:
  void clear_m_get_transaction();
  const ::proto::get_transaction& m_get_transaction() const;
  PROTOBUF_NODISCARD ::proto::get_transaction* release_m_get_transaction();
  ::proto::get_transaction* mutable_m_get_transaction();
  void set_allocated_m_get_transaction(::proto::get_transaction* m_get_transaction);
  private:
  const ::proto::get_transaction& _internal_m_get_transaction() const;
  ::proto::get_transaction* _internal_mutable_m_get_transaction();
  public:
  void unsafe_arena_set_allocated_m_get_transaction(
      ::proto::get_transaction* m_get_transaction);
  ::proto::get_transaction* unsafe_arena_release_m_get_transaction();

  // .proto.get_authorization_txid m_get_authorization_txid = 11;
  bool has_m_get_authorization_txid() const;
  private:
  bool _internal_has_m_get_authorization_txid() const;
  public:
  void clear_m_get_authorization_txid();
  const ::proto::get_authorization_txid& m_get_authorization_txid() const;
  PROTOBUF_NODISCARD ::proto::get_authorization_txid* release_m_get_authorization_txid();
  ::proto::get_authorization_txid* mutable_m_get_authorization_txid();
  void set_allocated_m_get_authorization_txid(::proto::get_authorization_txid* m_get_authorization_txid);
  private:
  const ::proto::get_authorization_txid& _internal_m_get_authorization_txid() const;
  ::proto::get_authorization_txid* _internal_mutable_m_get_authorization_txid();
  public:
  void unsafe_arena_set_allocated_m_get_authorization_txid(
      ::proto::get_authorization_txid* m_get_authorization_txid);
  ::proto::get_authorization_txid* unsafe_arena_release_m_get_authorization_txid();

  // .proto.get_all_finished_votings_for_voter m_get_all_finished_votings_for_voter = 12;
  bool has_m_get_all_finished_votings_for_voter() const;
  private:
  bool _internal_has_m_get_all_finished_votings_for_voter() const;
  public:
  void clear_m_get_all_finished_votings_for_voter();
  const ::proto::get_all_finished_votings_for_voter& m_get_all_finished_votings_for_voter() const;
  PROTOBUF_NODISCARD ::proto::get_all_finished_votings_for_voter* release_m_get_all_finished_votings_for_voter();
  ::proto::get_all_finished_votings_for_voter* mutable_m_get_all_finished_votings_for_voter();
  void set_allocated_m_get_all_finished_votings_for_voter(::proto::get_all_finished_votings_for_voter* m_get_all_finished_votings_for_voter);
  private:
  const ::proto::get_all_finished_votings_for_voter& _internal_m_get_all_finished_votings_for_voter() const;
  ::proto::get_all_finished_votings_for_voter* _internal_mutable_m_get_all_finished_votings_for_voter();
  public:
  void unsafe_arena_set_allocated_m_get_all_finished_votings_for_voter(
      ::proto::get_all_finished_votings_for_voter* m_get_all_finished_votings_for_voter);
  ::proto::get_all_finished_votings_for_voter* unsafe_arena_release_m_get_all_finished_votings_for_voter();

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:proto.request)
 private:
  class _Internal;
  void set_has_m_getheaders();
  void set_has_m_gettxs();
  void set_has_m_getblock();
  void set_has_m_getmempooltransactions();
  void set_has_m_getaddr();
  void set_has_m_getmerklebranch();
  void set_has_m_get_all_active_votings_for_voter();
  void set_has_m_get_amount_on_pkh();
  void set_has_m_get_transaction();
  void set_has_m_get_authorization_txid();
  void set_has_m_get_all_finished_votings_for_voter();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RequestTypeUnion {
    constexpr RequestTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::proto::getheaders* m_getheaders_;
    ::proto::gettxs* m_gettxs_;
    ::proto::getblock* m_getblock_;
    ::proto::getmempooltransactions* m_getmempooltransactions_;
    ::proto::getaddr* m_getaddr_;
    ::proto::getmerklebranch* m_getmerklebranch_;
    ::proto::get_all_active_votings_for_voter* m_get_all_active_votings_for_voter_;
    ::proto::get_amount_on_pkh* m_get_amount_on_pkh_;
    ::proto::get_transaction* m_get_transaction_;
    ::proto::get_authorization_txid* m_get_authorization_txid_;
    ::proto::get_all_finished_votings_for_voter* m_get_all_finished_votings_for_voter_;
  } request_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_p2p_2eproto;
};
// -------------------------------------------------------------------

class proto_massage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.proto_massage) */ {
 public:
  inline proto_massage() : proto_massage(nullptr) {}
  ~proto_massage() override;
  explicit constexpr proto_massage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  proto_massage(const proto_massage& from);
  proto_massage(proto_massage&& from) noexcept
    : proto_massage() {
    *this = ::std::move(from);
  }

  inline proto_massage& operator=(const proto_massage& from) {
    CopyFrom(from);
    return *this;
  }
  inline proto_massage& operator=(proto_massage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const proto_massage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kMRequest = 1,
    kMHeaders = 2,
    kMBlock = 3,
    kMTransaction = 4,
    kMAddr = 5,
    kMMerkleBranch = 7,
    kMAllActiveVotingsForVoter = 8,
    kMAmountOnPkh = 9,
    kMAuthorizationTxid = 10,
    kMAllFinishedVotingsForVoter = 11,
    MESSAGE_TYPE_NOT_SET = 0,
  };

  static inline const proto_massage* internal_default_instance() {
    return reinterpret_cast<const proto_massage*>(
               &_proto_massage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(proto_massage& a, proto_massage& b) {
    a.Swap(&b);
  }
  inline void Swap(proto_massage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(proto_massage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  proto_massage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<proto_massage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const proto_massage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const proto_massage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(proto_massage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.proto_massage";
  }
  protected:
  explicit proto_massage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMRequestFieldNumber = 1,
    kMHeadersFieldNumber = 2,
    kMBlockFieldNumber = 3,
    kMTransactionFieldNumber = 4,
    kMAddrFieldNumber = 5,
    kMMerkleBranchFieldNumber = 7,
    kMAllActiveVotingsForVoterFieldNumber = 8,
    kMAmountOnPkhFieldNumber = 9,
    kMAuthorizationTxidFieldNumber = 10,
    kMAllFinishedVotingsForVoterFieldNumber = 11,
  };
  // .proto.request m_request = 1;
  bool has_m_request() const;
  private:
  bool _internal_has_m_request() const;
  public:
  void clear_m_request();
  const ::proto::request& m_request() const;
  PROTOBUF_NODISCARD ::proto::request* release_m_request();
  ::proto::request* mutable_m_request();
  void set_allocated_m_request(::proto::request* m_request);
  private:
  const ::proto::request& _internal_m_request() const;
  ::proto::request* _internal_mutable_m_request();
  public:
  void unsafe_arena_set_allocated_m_request(
      ::proto::request* m_request);
  ::proto::request* unsafe_arena_release_m_request();

  // .proto.headers m_headers = 2;
  bool has_m_headers() const;
  private:
  bool _internal_has_m_headers() const;
  public:
  void clear_m_headers();
  const ::proto::headers& m_headers() const;
  PROTOBUF_NODISCARD ::proto::headers* release_m_headers();
  ::proto::headers* mutable_m_headers();
  void set_allocated_m_headers(::proto::headers* m_headers);
  private:
  const ::proto::headers& _internal_m_headers() const;
  ::proto::headers* _internal_mutable_m_headers();
  public:
  void unsafe_arena_set_allocated_m_headers(
      ::proto::headers* m_headers);
  ::proto::headers* unsafe_arena_release_m_headers();

  // .proto.block m_block = 3;
  bool has_m_block() const;
  private:
  bool _internal_has_m_block() const;
  public:
  void clear_m_block();
  const ::proto::block& m_block() const;
  PROTOBUF_NODISCARD ::proto::block* release_m_block();
  ::proto::block* mutable_m_block();
  void set_allocated_m_block(::proto::block* m_block);
  private:
  const ::proto::block& _internal_m_block() const;
  ::proto::block* _internal_mutable_m_block();
  public:
  void unsafe_arena_set_allocated_m_block(
      ::proto::block* m_block);
  ::proto::block* unsafe_arena_release_m_block();

  // .proto.transaction m_transaction = 4;
  bool has_m_transaction() const;
  private:
  bool _internal_has_m_transaction() const;
  public:
  void clear_m_transaction();
  const ::proto::transaction& m_transaction() const;
  PROTOBUF_NODISCARD ::proto::transaction* release_m_transaction();
  ::proto::transaction* mutable_m_transaction();
  void set_allocated_m_transaction(::proto::transaction* m_transaction);
  private:
  const ::proto::transaction& _internal_m_transaction() const;
  ::proto::transaction* _internal_mutable_m_transaction();
  public:
  void unsafe_arena_set_allocated_m_transaction(
      ::proto::transaction* m_transaction);
  ::proto::transaction* unsafe_arena_release_m_transaction();

  // .proto.addr m_addr = 5;
  bool has_m_addr() const;
  private:
  bool _internal_has_m_addr() const;
  public:
  void clear_m_addr();
  const ::proto::addr& m_addr() const;
  PROTOBUF_NODISCARD ::proto::addr* release_m_addr();
  ::proto::addr* mutable_m_addr();
  void set_allocated_m_addr(::proto::addr* m_addr);
  private:
  const ::proto::addr& _internal_m_addr() const;
  ::proto::addr* _internal_mutable_m_addr();
  public:
  void unsafe_arena_set_allocated_m_addr(
      ::proto::addr* m_addr);
  ::proto::addr* unsafe_arena_release_m_addr();

  // .proto.merkle_branch m_merkle_branch = 7;
  bool has_m_merkle_branch() const;
  private:
  bool _internal_has_m_merkle_branch() const;
  public:
  void clear_m_merkle_branch();
  const ::proto::merkle_branch& m_merkle_branch() const;
  PROTOBUF_NODISCARD ::proto::merkle_branch* release_m_merkle_branch();
  ::proto::merkle_branch* mutable_m_merkle_branch();
  void set_allocated_m_merkle_branch(::proto::merkle_branch* m_merkle_branch);
  private:
  const ::proto::merkle_branch& _internal_m_merkle_branch() const;
  ::proto::merkle_branch* _internal_mutable_m_merkle_branch();
  public:
  void unsafe_arena_set_allocated_m_merkle_branch(
      ::proto::merkle_branch* m_merkle_branch);
  ::proto::merkle_branch* unsafe_arena_release_m_merkle_branch();

  // .proto.all_active_votings_for_voter m_all_active_votings_for_voter = 8;
  bool has_m_all_active_votings_for_voter() const;
  private:
  bool _internal_has_m_all_active_votings_for_voter() const;
  public:
  void clear_m_all_active_votings_for_voter();
  const ::proto::all_active_votings_for_voter& m_all_active_votings_for_voter() const;
  PROTOBUF_NODISCARD ::proto::all_active_votings_for_voter* release_m_all_active_votings_for_voter();
  ::proto::all_active_votings_for_voter* mutable_m_all_active_votings_for_voter();
  void set_allocated_m_all_active_votings_for_voter(::proto::all_active_votings_for_voter* m_all_active_votings_for_voter);
  private:
  const ::proto::all_active_votings_for_voter& _internal_m_all_active_votings_for_voter() const;
  ::proto::all_active_votings_for_voter* _internal_mutable_m_all_active_votings_for_voter();
  public:
  void unsafe_arena_set_allocated_m_all_active_votings_for_voter(
      ::proto::all_active_votings_for_voter* m_all_active_votings_for_voter);
  ::proto::all_active_votings_for_voter* unsafe_arena_release_m_all_active_votings_for_voter();

  // .proto.amount_on_pkh m_amount_on_pkh = 9;
  bool has_m_amount_on_pkh() const;
  private:
  bool _internal_has_m_amount_on_pkh() const;
  public:
  void clear_m_amount_on_pkh();
  const ::proto::amount_on_pkh& m_amount_on_pkh() const;
  PROTOBUF_NODISCARD ::proto::amount_on_pkh* release_m_amount_on_pkh();
  ::proto::amount_on_pkh* mutable_m_amount_on_pkh();
  void set_allocated_m_amount_on_pkh(::proto::amount_on_pkh* m_amount_on_pkh);
  private:
  const ::proto::amount_on_pkh& _internal_m_amount_on_pkh() const;
  ::proto::amount_on_pkh* _internal_mutable_m_amount_on_pkh();
  public:
  void unsafe_arena_set_allocated_m_amount_on_pkh(
      ::proto::amount_on_pkh* m_amount_on_pkh);
  ::proto::amount_on_pkh* unsafe_arena_release_m_amount_on_pkh();

  // .proto.authorization_txid m_authorization_txid = 10;
  bool has_m_authorization_txid() const;
  private:
  bool _internal_has_m_authorization_txid() const;
  public:
  void clear_m_authorization_txid();
  const ::proto::authorization_txid& m_authorization_txid() const;
  PROTOBUF_NODISCARD ::proto::authorization_txid* release_m_authorization_txid();
  ::proto::authorization_txid* mutable_m_authorization_txid();
  void set_allocated_m_authorization_txid(::proto::authorization_txid* m_authorization_txid);
  private:
  const ::proto::authorization_txid& _internal_m_authorization_txid() const;
  ::proto::authorization_txid* _internal_mutable_m_authorization_txid();
  public:
  void unsafe_arena_set_allocated_m_authorization_txid(
      ::proto::authorization_txid* m_authorization_txid);
  ::proto::authorization_txid* unsafe_arena_release_m_authorization_txid();

  // .proto.all_finished_votings_for_voter m_all_finished_votings_for_voter = 11;
  bool has_m_all_finished_votings_for_voter() const;
  private:
  bool _internal_has_m_all_finished_votings_for_voter() const;
  public:
  void clear_m_all_finished_votings_for_voter();
  const ::proto::all_finished_votings_for_voter& m_all_finished_votings_for_voter() const;
  PROTOBUF_NODISCARD ::proto::all_finished_votings_for_voter* release_m_all_finished_votings_for_voter();
  ::proto::all_finished_votings_for_voter* mutable_m_all_finished_votings_for_voter();
  void set_allocated_m_all_finished_votings_for_voter(::proto::all_finished_votings_for_voter* m_all_finished_votings_for_voter);
  private:
  const ::proto::all_finished_votings_for_voter& _internal_m_all_finished_votings_for_voter() const;
  ::proto::all_finished_votings_for_voter* _internal_mutable_m_all_finished_votings_for_voter();
  public:
  void unsafe_arena_set_allocated_m_all_finished_votings_for_voter(
      ::proto::all_finished_votings_for_voter* m_all_finished_votings_for_voter);
  ::proto::all_finished_votings_for_voter* unsafe_arena_release_m_all_finished_votings_for_voter();

  void clear_message_type();
  MessageTypeCase message_type_case() const;
  // @@protoc_insertion_point(class_scope:proto.proto_massage)
 private:
  class _Internal;
  void set_has_m_request();
  void set_has_m_headers();
  void set_has_m_block();
  void set_has_m_transaction();
  void set_has_m_addr();
  void set_has_m_merkle_branch();
  void set_has_m_all_active_votings_for_voter();
  void set_has_m_amount_on_pkh();
  void set_has_m_authorization_txid();
  void set_has_m_all_finished_votings_for_voter();

  inline bool has_message_type() const;
  inline void clear_has_message_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MessageTypeUnion {
    constexpr MessageTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::proto::request* m_request_;
    ::proto::headers* m_headers_;
    ::proto::block* m_block_;
    ::proto::transaction* m_transaction_;
    ::proto::addr* m_addr_;
    ::proto::merkle_branch* m_merkle_branch_;
    ::proto::all_active_votings_for_voter* m_all_active_votings_for_voter_;
    ::proto::amount_on_pkh* m_amount_on_pkh_;
    ::proto::authorization_txid* m_authorization_txid_;
    ::proto::all_finished_votings_for_voter* m_all_finished_votings_for_voter_;
  } message_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_p2p_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// transaction_vin

// bytes m_txid = 1;
inline void transaction_vin::clear_m_txid() {
  m_txid_.ClearToEmpty();
}
inline const std::string& transaction_vin::m_txid() const {
  // @@protoc_insertion_point(field_get:proto.transaction.vin.m_txid)
  return _internal_m_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void transaction_vin::set_m_txid(ArgT0&& arg0, ArgT... args) {
 
 m_txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.transaction.vin.m_txid)
}
inline std::string* transaction_vin::mutable_m_txid() {
  std::string* _s = _internal_mutable_m_txid();
  // @@protoc_insertion_point(field_mutable:proto.transaction.vin.m_txid)
  return _s;
}
inline const std::string& transaction_vin::_internal_m_txid() const {
  return m_txid_.Get();
}
inline void transaction_vin::_internal_set_m_txid(const std::string& value) {
  
  m_txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* transaction_vin::_internal_mutable_m_txid() {
  
  return m_txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* transaction_vin::release_m_txid() {
  // @@protoc_insertion_point(field_release:proto.transaction.vin.m_txid)
  return m_txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void transaction_vin::set_allocated_m_txid(std::string* m_txid) {
  if (m_txid != nullptr) {
    
  } else {
    
  }
  m_txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_txid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.transaction.vin.m_txid)
}

// optional bytes m_sign = 2;
inline bool transaction_vin::_internal_has_m_sign() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool transaction_vin::has_m_sign() const {
  return _internal_has_m_sign();
}
inline void transaction_vin::clear_m_sign() {
  m_sign_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& transaction_vin::m_sign() const {
  // @@protoc_insertion_point(field_get:proto.transaction.vin.m_sign)
  return _internal_m_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void transaction_vin::set_m_sign(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 m_sign_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.transaction.vin.m_sign)
}
inline std::string* transaction_vin::mutable_m_sign() {
  std::string* _s = _internal_mutable_m_sign();
  // @@protoc_insertion_point(field_mutable:proto.transaction.vin.m_sign)
  return _s;
}
inline const std::string& transaction_vin::_internal_m_sign() const {
  return m_sign_.Get();
}
inline void transaction_vin::_internal_set_m_sign(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  m_sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* transaction_vin::_internal_mutable_m_sign() {
  _has_bits_[0] |= 0x00000001u;
  return m_sign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* transaction_vin::release_m_sign() {
  // @@protoc_insertion_point(field_release:proto.transaction.vin.m_sign)
  if (!_internal_has_m_sign()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = m_sign_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_sign_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void transaction_vin::set_allocated_m_sign(std::string* m_sign) {
  if (m_sign != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  m_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_sign,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_sign_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.transaction.vin.m_sign)
}

// bytes m_pk = 3;
inline void transaction_vin::clear_m_pk() {
  m_pk_.ClearToEmpty();
}
inline const std::string& transaction_vin::m_pk() const {
  // @@protoc_insertion_point(field_get:proto.transaction.vin.m_pk)
  return _internal_m_pk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void transaction_vin::set_m_pk(ArgT0&& arg0, ArgT... args) {
 
 m_pk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.transaction.vin.m_pk)
}
inline std::string* transaction_vin::mutable_m_pk() {
  std::string* _s = _internal_mutable_m_pk();
  // @@protoc_insertion_point(field_mutable:proto.transaction.vin.m_pk)
  return _s;
}
inline const std::string& transaction_vin::_internal_m_pk() const {
  return m_pk_.Get();
}
inline void transaction_vin::_internal_set_m_pk(const std::string& value) {
  
  m_pk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* transaction_vin::_internal_mutable_m_pk() {
  
  return m_pk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* transaction_vin::release_m_pk() {
  // @@protoc_insertion_point(field_release:proto.transaction.vin.m_pk)
  return m_pk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void transaction_vin::set_allocated_m_pk(std::string* m_pk) {
  if (m_pk != nullptr) {
    
  } else {
    
  }
  m_pk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_pk,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_pk_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_pk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.transaction.vin.m_pk)
}

// -------------------------------------------------------------------

// transaction_vout

// bytes m_pkh = 1;
inline void transaction_vout::clear_m_pkh() {
  m_pkh_.ClearToEmpty();
}
inline const std::string& transaction_vout::m_pkh() const {
  // @@protoc_insertion_point(field_get:proto.transaction.vout.m_pkh)
  return _internal_m_pkh();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void transaction_vout::set_m_pkh(ArgT0&& arg0, ArgT... args) {
 
 m_pkh_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.transaction.vout.m_pkh)
}
inline std::string* transaction_vout::mutable_m_pkh() {
  std::string* _s = _internal_mutable_m_pkh();
  // @@protoc_insertion_point(field_mutable:proto.transaction.vout.m_pkh)
  return _s;
}
inline const std::string& transaction_vout::_internal_m_pkh() const {
  return m_pkh_.Get();
}
inline void transaction_vout::_internal_set_m_pkh(const std::string& value) {
  
  m_pkh_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* transaction_vout::_internal_mutable_m_pkh() {
  
  return m_pkh_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* transaction_vout::release_m_pkh() {
  // @@protoc_insertion_point(field_release:proto.transaction.vout.m_pkh)
  return m_pkh_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void transaction_vout::set_allocated_m_pkh(std::string* m_pkh) {
  if (m_pkh != nullptr) {
    
  } else {
    
  }
  m_pkh_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_pkh,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_pkh_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_pkh_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.transaction.vout.m_pkh)
}

// fixed32 m_amount = 2;
inline void transaction_vout::clear_m_amount() {
  m_amount_ = 0u;
}
inline uint32_t transaction_vout::_internal_m_amount() const {
  return m_amount_;
}
inline uint32_t transaction_vout::m_amount() const {
  // @@protoc_insertion_point(field_get:proto.transaction.vout.m_amount)
  return _internal_m_amount();
}
inline void transaction_vout::_internal_set_m_amount(uint32_t value) {
  
  m_amount_ = value;
}
inline void transaction_vout::set_m_amount(uint32_t value) {
  _internal_set_m_amount(value);
  // @@protoc_insertion_point(field_set:proto.transaction.vout.m_amount)
}

// -------------------------------------------------------------------

// transaction

// .proto.transaction.transactiontype m_type = 1;
inline void transaction::clear_m_type() {
  m_type_ = 0;
}
inline ::proto::transaction_transactiontype transaction::_internal_m_type() const {
  return static_cast< ::proto::transaction_transactiontype >(m_type_);
}
inline ::proto::transaction_transactiontype transaction::m_type() const {
  // @@protoc_insertion_point(field_get:proto.transaction.m_type)
  return _internal_m_type();
}
inline void transaction::_internal_set_m_type(::proto::transaction_transactiontype value) {
  
  m_type_ = value;
}
inline void transaction::set_m_type(::proto::transaction_transactiontype value) {
  _internal_set_m_type(value);
  // @@protoc_insertion_point(field_set:proto.transaction.m_type)
}

// repeated .proto.transaction.vin m_vin = 2;
inline int transaction::_internal_m_vin_size() const {
  return m_vin_.size();
}
inline int transaction::m_vin_size() const {
  return _internal_m_vin_size();
}
inline void transaction::clear_m_vin() {
  m_vin_.Clear();
}
inline ::proto::transaction_vin* transaction::mutable_m_vin(int index) {
  // @@protoc_insertion_point(field_mutable:proto.transaction.m_vin)
  return m_vin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vin >*
transaction::mutable_m_vin() {
  // @@protoc_insertion_point(field_mutable_list:proto.transaction.m_vin)
  return &m_vin_;
}
inline const ::proto::transaction_vin& transaction::_internal_m_vin(int index) const {
  return m_vin_.Get(index);
}
inline const ::proto::transaction_vin& transaction::m_vin(int index) const {
  // @@protoc_insertion_point(field_get:proto.transaction.m_vin)
  return _internal_m_vin(index);
}
inline ::proto::transaction_vin* transaction::_internal_add_m_vin() {
  return m_vin_.Add();
}
inline ::proto::transaction_vin* transaction::add_m_vin() {
  ::proto::transaction_vin* _add = _internal_add_m_vin();
  // @@protoc_insertion_point(field_add:proto.transaction.m_vin)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vin >&
transaction::m_vin() const {
  // @@protoc_insertion_point(field_list:proto.transaction.m_vin)
  return m_vin_;
}

// repeated .proto.transaction.vout m_vout = 3;
inline int transaction::_internal_m_vout_size() const {
  return m_vout_.size();
}
inline int transaction::m_vout_size() const {
  return _internal_m_vout_size();
}
inline void transaction::clear_m_vout() {
  m_vout_.Clear();
}
inline ::proto::transaction_vout* transaction::mutable_m_vout(int index) {
  // @@protoc_insertion_point(field_mutable:proto.transaction.m_vout)
  return m_vout_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vout >*
transaction::mutable_m_vout() {
  // @@protoc_insertion_point(field_mutable_list:proto.transaction.m_vout)
  return &m_vout_;
}
inline const ::proto::transaction_vout& transaction::_internal_m_vout(int index) const {
  return m_vout_.Get(index);
}
inline const ::proto::transaction_vout& transaction::m_vout(int index) const {
  // @@protoc_insertion_point(field_get:proto.transaction.m_vout)
  return _internal_m_vout(index);
}
inline ::proto::transaction_vout* transaction::_internal_add_m_vout() {
  return m_vout_.Add();
}
inline ::proto::transaction_vout* transaction::add_m_vout() {
  ::proto::transaction_vout* _add = _internal_add_m_vout();
  // @@protoc_insertion_point(field_add:proto.transaction.m_vout)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction_vout >&
transaction::m_vout() const {
  // @@protoc_insertion_point(field_list:proto.transaction.m_vout)
  return m_vout_;
}

// bytes m_txid = 4;
inline void transaction::clear_m_txid() {
  m_txid_.ClearToEmpty();
}
inline const std::string& transaction::m_txid() const {
  // @@protoc_insertion_point(field_get:proto.transaction.m_txid)
  return _internal_m_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void transaction::set_m_txid(ArgT0&& arg0, ArgT... args) {
 
 m_txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.transaction.m_txid)
}
inline std::string* transaction::mutable_m_txid() {
  std::string* _s = _internal_mutable_m_txid();
  // @@protoc_insertion_point(field_mutable:proto.transaction.m_txid)
  return _s;
}
inline const std::string& transaction::_internal_m_txid() const {
  return m_txid_.Get();
}
inline void transaction::_internal_set_m_txid(const std::string& value) {
  
  m_txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* transaction::_internal_mutable_m_txid() {
  
  return m_txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* transaction::release_m_txid() {
  // @@protoc_insertion_point(field_release:proto.transaction.m_txid)
  return m_txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void transaction::set_allocated_m_txid(std::string* m_txid) {
  if (m_txid != nullptr) {
    
  } else {
    
  }
  m_txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_txid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.transaction.m_txid)
}

// bytes m_allmetadata = 5;
inline void transaction::clear_m_allmetadata() {
  m_allmetadata_.ClearToEmpty();
}
inline const std::string& transaction::m_allmetadata() const {
  // @@protoc_insertion_point(field_get:proto.transaction.m_allmetadata)
  return _internal_m_allmetadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void transaction::set_m_allmetadata(ArgT0&& arg0, ArgT... args) {
 
 m_allmetadata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.transaction.m_allmetadata)
}
inline std::string* transaction::mutable_m_allmetadata() {
  std::string* _s = _internal_mutable_m_allmetadata();
  // @@protoc_insertion_point(field_mutable:proto.transaction.m_allmetadata)
  return _s;
}
inline const std::string& transaction::_internal_m_allmetadata() const {
  return m_allmetadata_.Get();
}
inline void transaction::_internal_set_m_allmetadata(const std::string& value) {
  
  m_allmetadata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* transaction::_internal_mutable_m_allmetadata() {
  
  return m_allmetadata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* transaction::release_m_allmetadata() {
  // @@protoc_insertion_point(field_release:proto.transaction.m_allmetadata)
  return m_allmetadata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void transaction::set_allocated_m_allmetadata(std::string* m_allmetadata) {
  if (m_allmetadata != nullptr) {
    
  } else {
    
  }
  m_allmetadata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_allmetadata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_allmetadata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_allmetadata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.transaction.m_allmetadata)
}

// -------------------------------------------------------------------

// header

// fixed32 m_version = 1;
inline void header::clear_m_version() {
  m_version_ = 0u;
}
inline uint32_t header::_internal_m_version() const {
  return m_version_;
}
inline uint32_t header::m_version() const {
  // @@protoc_insertion_point(field_get:proto.header.m_version)
  return _internal_m_version();
}
inline void header::_internal_set_m_version(uint32_t value) {
  
  m_version_ = value;
}
inline void header::set_m_version(uint32_t value) {
  _internal_set_m_version(value);
  // @@protoc_insertion_point(field_set:proto.header.m_version)
}

// bytes m_parent_hash = 2;
inline void header::clear_m_parent_hash() {
  m_parent_hash_.ClearToEmpty();
}
inline const std::string& header::m_parent_hash() const {
  // @@protoc_insertion_point(field_get:proto.header.m_parent_hash)
  return _internal_m_parent_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void header::set_m_parent_hash(ArgT0&& arg0, ArgT... args) {
 
 m_parent_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.header.m_parent_hash)
}
inline std::string* header::mutable_m_parent_hash() {
  std::string* _s = _internal_mutable_m_parent_hash();
  // @@protoc_insertion_point(field_mutable:proto.header.m_parent_hash)
  return _s;
}
inline const std::string& header::_internal_m_parent_hash() const {
  return m_parent_hash_.Get();
}
inline void header::_internal_set_m_parent_hash(const std::string& value) {
  
  m_parent_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* header::_internal_mutable_m_parent_hash() {
  
  return m_parent_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* header::release_m_parent_hash() {
  // @@protoc_insertion_point(field_release:proto.header.m_parent_hash)
  return m_parent_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void header::set_allocated_m_parent_hash(std::string* m_parent_hash) {
  if (m_parent_hash != nullptr) {
    
  } else {
    
  }
  m_parent_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_parent_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_parent_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_parent_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.header.m_parent_hash)
}

// bytes m_actual_hash = 3;
inline void header::clear_m_actual_hash() {
  m_actual_hash_.ClearToEmpty();
}
inline const std::string& header::m_actual_hash() const {
  // @@protoc_insertion_point(field_get:proto.header.m_actual_hash)
  return _internal_m_actual_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void header::set_m_actual_hash(ArgT0&& arg0, ArgT... args) {
 
 m_actual_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.header.m_actual_hash)
}
inline std::string* header::mutable_m_actual_hash() {
  std::string* _s = _internal_mutable_m_actual_hash();
  // @@protoc_insertion_point(field_mutable:proto.header.m_actual_hash)
  return _s;
}
inline const std::string& header::_internal_m_actual_hash() const {
  return m_actual_hash_.Get();
}
inline void header::_internal_set_m_actual_hash(const std::string& value) {
  
  m_actual_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* header::_internal_mutable_m_actual_hash() {
  
  return m_actual_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* header::release_m_actual_hash() {
  // @@protoc_insertion_point(field_release:proto.header.m_actual_hash)
  return m_actual_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void header::set_allocated_m_actual_hash(std::string* m_actual_hash) {
  if (m_actual_hash != nullptr) {
    
  } else {
    
  }
  m_actual_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_actual_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_actual_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_actual_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.header.m_actual_hash)
}

// fixed32 m_block_time = 4;
inline void header::clear_m_block_time() {
  m_block_time_ = 0u;
}
inline uint32_t header::_internal_m_block_time() const {
  return m_block_time_;
}
inline uint32_t header::m_block_time() const {
  // @@protoc_insertion_point(field_get:proto.header.m_block_time)
  return _internal_m_block_time();
}
inline void header::_internal_set_m_block_time(uint32_t value) {
  
  m_block_time_ = value;
}
inline void header::set_m_block_time(uint32_t value) {
  _internal_set_m_block_time(value);
  // @@protoc_insertion_point(field_set:proto.header.m_block_time)
}

// bytes m_all_tx_hash = 5;
inline void header::clear_m_all_tx_hash() {
  m_all_tx_hash_.ClearToEmpty();
}
inline const std::string& header::m_all_tx_hash() const {
  // @@protoc_insertion_point(field_get:proto.header.m_all_tx_hash)
  return _internal_m_all_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void header::set_m_all_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 m_all_tx_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.header.m_all_tx_hash)
}
inline std::string* header::mutable_m_all_tx_hash() {
  std::string* _s = _internal_mutable_m_all_tx_hash();
  // @@protoc_insertion_point(field_mutable:proto.header.m_all_tx_hash)
  return _s;
}
inline const std::string& header::_internal_m_all_tx_hash() const {
  return m_all_tx_hash_.Get();
}
inline void header::_internal_set_m_all_tx_hash(const std::string& value) {
  
  m_all_tx_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* header::_internal_mutable_m_all_tx_hash() {
  
  return m_all_tx_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* header::release_m_all_tx_hash() {
  // @@protoc_insertion_point(field_release:proto.header.m_all_tx_hash)
  return m_all_tx_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void header::set_allocated_m_all_tx_hash(std::string* m_all_tx_hash) {
  if (m_all_tx_hash != nullptr) {
    
  } else {
    
  }
  m_all_tx_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_all_tx_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_all_tx_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_all_tx_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.header.m_all_tx_hash)
}

// repeated bytes m_all_signatures = 6;
inline int header::_internal_m_all_signatures_size() const {
  return m_all_signatures_.size();
}
inline int header::m_all_signatures_size() const {
  return _internal_m_all_signatures_size();
}
inline void header::clear_m_all_signatures() {
  m_all_signatures_.Clear();
}
inline std::string* header::add_m_all_signatures() {
  std::string* _s = _internal_add_m_all_signatures();
  // @@protoc_insertion_point(field_add_mutable:proto.header.m_all_signatures)
  return _s;
}
inline const std::string& header::_internal_m_all_signatures(int index) const {
  return m_all_signatures_.Get(index);
}
inline const std::string& header::m_all_signatures(int index) const {
  // @@protoc_insertion_point(field_get:proto.header.m_all_signatures)
  return _internal_m_all_signatures(index);
}
inline std::string* header::mutable_m_all_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:proto.header.m_all_signatures)
  return m_all_signatures_.Mutable(index);
}
inline void header::set_m_all_signatures(int index, const std::string& value) {
  m_all_signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.header.m_all_signatures)
}
inline void header::set_m_all_signatures(int index, std::string&& value) {
  m_all_signatures_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.header.m_all_signatures)
}
inline void header::set_m_all_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  m_all_signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.header.m_all_signatures)
}
inline void header::set_m_all_signatures(int index, const void* value, size_t size) {
  m_all_signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.header.m_all_signatures)
}
inline std::string* header::_internal_add_m_all_signatures() {
  return m_all_signatures_.Add();
}
inline void header::add_m_all_signatures(const std::string& value) {
  m_all_signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.header.m_all_signatures)
}
inline void header::add_m_all_signatures(std::string&& value) {
  m_all_signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.header.m_all_signatures)
}
inline void header::add_m_all_signatures(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  m_all_signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.header.m_all_signatures)
}
inline void header::add_m_all_signatures(const void* value, size_t size) {
  m_all_signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.header.m_all_signatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
header::m_all_signatures() const {
  // @@protoc_insertion_point(field_list:proto.header.m_all_signatures)
  return m_all_signatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
header::mutable_m_all_signatures() {
  // @@protoc_insertion_point(field_mutable_list:proto.header.m_all_signatures)
  return &m_all_signatures_;
}

// -------------------------------------------------------------------

// headers

// repeated .proto.header m_headers = 1;
inline int headers::_internal_m_headers_size() const {
  return m_headers_.size();
}
inline int headers::m_headers_size() const {
  return _internal_m_headers_size();
}
inline void headers::clear_m_headers() {
  m_headers_.Clear();
}
inline ::proto::header* headers::mutable_m_headers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.headers.m_headers)
  return m_headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::header >*
headers::mutable_m_headers() {
  // @@protoc_insertion_point(field_mutable_list:proto.headers.m_headers)
  return &m_headers_;
}
inline const ::proto::header& headers::_internal_m_headers(int index) const {
  return m_headers_.Get(index);
}
inline const ::proto::header& headers::m_headers(int index) const {
  // @@protoc_insertion_point(field_get:proto.headers.m_headers)
  return _internal_m_headers(index);
}
inline ::proto::header* headers::_internal_add_m_headers() {
  return m_headers_.Add();
}
inline ::proto::header* headers::add_m_headers() {
  ::proto::header* _add = _internal_add_m_headers();
  // @@protoc_insertion_point(field_add:proto.headers.m_headers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::header >&
headers::m_headers() const {
  // @@protoc_insertion_point(field_list:proto.headers.m_headers)
  return m_headers_;
}

// -------------------------------------------------------------------

// block

// .proto.header m_header = 1;
inline bool block::_internal_has_m_header() const {
  return this != internal_default_instance() && m_header_ != nullptr;
}
inline bool block::has_m_header() const {
  return _internal_has_m_header();
}
inline void block::clear_m_header() {
  if (GetArenaForAllocation() == nullptr && m_header_ != nullptr) {
    delete m_header_;
  }
  m_header_ = nullptr;
}
inline const ::proto::header& block::_internal_m_header() const {
  const ::proto::header* p = m_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::header&>(
      ::proto::_header_default_instance_);
}
inline const ::proto::header& block::m_header() const {
  // @@protoc_insertion_point(field_get:proto.block.m_header)
  return _internal_m_header();
}
inline void block::unsafe_arena_set_allocated_m_header(
    ::proto::header* m_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(m_header_);
  }
  m_header_ = m_header;
  if (m_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.block.m_header)
}
inline ::proto::header* block::release_m_header() {
  
  ::proto::header* temp = m_header_;
  m_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::header* block::unsafe_arena_release_m_header() {
  // @@protoc_insertion_point(field_release:proto.block.m_header)
  
  ::proto::header* temp = m_header_;
  m_header_ = nullptr;
  return temp;
}
inline ::proto::header* block::_internal_mutable_m_header() {
  
  if (m_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::header>(GetArenaForAllocation());
    m_header_ = p;
  }
  return m_header_;
}
inline ::proto::header* block::mutable_m_header() {
  ::proto::header* _msg = _internal_mutable_m_header();
  // @@protoc_insertion_point(field_mutable:proto.block.m_header)
  return _msg;
}
inline void block::set_allocated_m_header(::proto::header* m_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete m_header_;
  }
  if (m_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::header>::GetOwningArena(m_header);
    if (message_arena != submessage_arena) {
      m_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_header, submessage_arena);
    }
    
  } else {
    
  }
  m_header_ = m_header;
  // @@protoc_insertion_point(field_set_allocated:proto.block.m_header)
}

// repeated .proto.transaction m_transaction = 2;
inline int block::_internal_m_transaction_size() const {
  return m_transaction_.size();
}
inline int block::m_transaction_size() const {
  return _internal_m_transaction_size();
}
inline void block::clear_m_transaction() {
  m_transaction_.Clear();
}
inline ::proto::transaction* block::mutable_m_transaction(int index) {
  // @@protoc_insertion_point(field_mutable:proto.block.m_transaction)
  return m_transaction_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction >*
block::mutable_m_transaction() {
  // @@protoc_insertion_point(field_mutable_list:proto.block.m_transaction)
  return &m_transaction_;
}
inline const ::proto::transaction& block::_internal_m_transaction(int index) const {
  return m_transaction_.Get(index);
}
inline const ::proto::transaction& block::m_transaction(int index) const {
  // @@protoc_insertion_point(field_get:proto.block.m_transaction)
  return _internal_m_transaction(index);
}
inline ::proto::transaction* block::_internal_add_m_transaction() {
  return m_transaction_.Add();
}
inline ::proto::transaction* block::add_m_transaction() {
  ::proto::transaction* _add = _internal_add_m_transaction();
  // @@protoc_insertion_point(field_add:proto.block.m_transaction)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::transaction >&
block::m_transaction() const {
  // @@protoc_insertion_point(field_list:proto.block.m_transaction)
  return m_transaction_;
}

// -------------------------------------------------------------------

// addr_peer_details

// string m_address = 1;
inline void addr_peer_details::clear_m_address() {
  m_address_.ClearToEmpty();
}
inline const std::string& addr_peer_details::m_address() const {
  // @@protoc_insertion_point(field_get:proto.addr.peer_details.m_address)
  return _internal_m_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void addr_peer_details::set_m_address(ArgT0&& arg0, ArgT... args) {
 
 m_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.addr.peer_details.m_address)
}
inline std::string* addr_peer_details::mutable_m_address() {
  std::string* _s = _internal_mutable_m_address();
  // @@protoc_insertion_point(field_mutable:proto.addr.peer_details.m_address)
  return _s;
}
inline const std::string& addr_peer_details::_internal_m_address() const {
  return m_address_.Get();
}
inline void addr_peer_details::_internal_set_m_address(const std::string& value) {
  
  m_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* addr_peer_details::_internal_mutable_m_address() {
  
  return m_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* addr_peer_details::release_m_address() {
  // @@protoc_insertion_point(field_release:proto.addr.peer_details.m_address)
  return m_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void addr_peer_details::set_allocated_m_address(std::string* m_address) {
  if (m_address != nullptr) {
    
  } else {
    
  }
  m_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.addr.peer_details.m_address)
}

// uint32 m_port = 2;
inline void addr_peer_details::clear_m_port() {
  m_port_ = 0u;
}
inline uint32_t addr_peer_details::_internal_m_port() const {
  return m_port_;
}
inline uint32_t addr_peer_details::m_port() const {
  // @@protoc_insertion_point(field_get:proto.addr.peer_details.m_port)
  return _internal_m_port();
}
inline void addr_peer_details::_internal_set_m_port(uint32_t value) {
  
  m_port_ = value;
}
inline void addr_peer_details::set_m_port(uint32_t value) {
  _internal_set_m_port(value);
  // @@protoc_insertion_point(field_set:proto.addr.peer_details.m_port)
}

// uint64 m_timestamp = 3;
inline void addr_peer_details::clear_m_timestamp() {
  m_timestamp_ = uint64_t{0u};
}
inline uint64_t addr_peer_details::_internal_m_timestamp() const {
  return m_timestamp_;
}
inline uint64_t addr_peer_details::m_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.addr.peer_details.m_timestamp)
  return _internal_m_timestamp();
}
inline void addr_peer_details::_internal_set_m_timestamp(uint64_t value) {
  
  m_timestamp_ = value;
}
inline void addr_peer_details::set_m_timestamp(uint64_t value) {
  _internal_set_m_timestamp(value);
  // @@protoc_insertion_point(field_set:proto.addr.peer_details.m_timestamp)
}

// -------------------------------------------------------------------

// addr

// repeated .proto.addr.peer_details m_peer_list = 1;
inline int addr::_internal_m_peer_list_size() const {
  return m_peer_list_.size();
}
inline int addr::m_peer_list_size() const {
  return _internal_m_peer_list_size();
}
inline void addr::clear_m_peer_list() {
  m_peer_list_.Clear();
}
inline ::proto::addr_peer_details* addr::mutable_m_peer_list(int index) {
  // @@protoc_insertion_point(field_mutable:proto.addr.m_peer_list)
  return m_peer_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::addr_peer_details >*
addr::mutable_m_peer_list() {
  // @@protoc_insertion_point(field_mutable_list:proto.addr.m_peer_list)
  return &m_peer_list_;
}
inline const ::proto::addr_peer_details& addr::_internal_m_peer_list(int index) const {
  return m_peer_list_.Get(index);
}
inline const ::proto::addr_peer_details& addr::m_peer_list(int index) const {
  // @@protoc_insertion_point(field_get:proto.addr.m_peer_list)
  return _internal_m_peer_list(index);
}
inline ::proto::addr_peer_details* addr::_internal_add_m_peer_list() {
  return m_peer_list_.Add();
}
inline ::proto::addr_peer_details* addr::add_m_peer_list() {
  ::proto::addr_peer_details* _add = _internal_add_m_peer_list();
  // @@protoc_insertion_point(field_add:proto.addr.m_peer_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::addr_peer_details >&
addr::m_peer_list() const {
  // @@protoc_insertion_point(field_list:proto.addr.m_peer_list)
  return m_peer_list_;
}

// -------------------------------------------------------------------

// all_active_votings_for_voter

// repeated bytes m_voting_ids = 1;
inline int all_active_votings_for_voter::_internal_m_voting_ids_size() const {
  return m_voting_ids_.size();
}
inline int all_active_votings_for_voter::m_voting_ids_size() const {
  return _internal_m_voting_ids_size();
}
inline void all_active_votings_for_voter::clear_m_voting_ids() {
  m_voting_ids_.Clear();
}
inline std::string* all_active_votings_for_voter::add_m_voting_ids() {
  std::string* _s = _internal_add_m_voting_ids();
  // @@protoc_insertion_point(field_add_mutable:proto.all_active_votings_for_voter.m_voting_ids)
  return _s;
}
inline const std::string& all_active_votings_for_voter::_internal_m_voting_ids(int index) const {
  return m_voting_ids_.Get(index);
}
inline const std::string& all_active_votings_for_voter::m_voting_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.all_active_votings_for_voter.m_voting_ids)
  return _internal_m_voting_ids(index);
}
inline std::string* all_active_votings_for_voter::mutable_m_voting_ids(int index) {
  // @@protoc_insertion_point(field_mutable:proto.all_active_votings_for_voter.m_voting_ids)
  return m_voting_ids_.Mutable(index);
}
inline void all_active_votings_for_voter::set_m_voting_ids(int index, const std::string& value) {
  m_voting_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.all_active_votings_for_voter.m_voting_ids)
}
inline void all_active_votings_for_voter::set_m_voting_ids(int index, std::string&& value) {
  m_voting_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.all_active_votings_for_voter.m_voting_ids)
}
inline void all_active_votings_for_voter::set_m_voting_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  m_voting_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.all_active_votings_for_voter.m_voting_ids)
}
inline void all_active_votings_for_voter::set_m_voting_ids(int index, const void* value, size_t size) {
  m_voting_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.all_active_votings_for_voter.m_voting_ids)
}
inline std::string* all_active_votings_for_voter::_internal_add_m_voting_ids() {
  return m_voting_ids_.Add();
}
inline void all_active_votings_for_voter::add_m_voting_ids(const std::string& value) {
  m_voting_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.all_active_votings_for_voter.m_voting_ids)
}
inline void all_active_votings_for_voter::add_m_voting_ids(std::string&& value) {
  m_voting_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.all_active_votings_for_voter.m_voting_ids)
}
inline void all_active_votings_for_voter::add_m_voting_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  m_voting_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.all_active_votings_for_voter.m_voting_ids)
}
inline void all_active_votings_for_voter::add_m_voting_ids(const void* value, size_t size) {
  m_voting_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.all_active_votings_for_voter.m_voting_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
all_active_votings_for_voter::m_voting_ids() const {
  // @@protoc_insertion_point(field_list:proto.all_active_votings_for_voter.m_voting_ids)
  return m_voting_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
all_active_votings_for_voter::mutable_m_voting_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.all_active_votings_for_voter.m_voting_ids)
  return &m_voting_ids_;
}

// -------------------------------------------------------------------

// getheaders

// fixed32 m_version = 1;
inline void getheaders::clear_m_version() {
  m_version_ = 0u;
}
inline uint32_t getheaders::_internal_m_version() const {
  return m_version_;
}
inline uint32_t getheaders::m_version() const {
  // @@protoc_insertion_point(field_get:proto.getheaders.m_version)
  return _internal_m_version();
}
inline void getheaders::_internal_set_m_version(uint32_t value) {
  
  m_version_ = value;
}
inline void getheaders::set_m_version(uint32_t value) {
  _internal_set_m_version(value);
  // @@protoc_insertion_point(field_set:proto.getheaders.m_version)
}

// bytes m_hash_header_start = 2;
inline void getheaders::clear_m_hash_header_start() {
  m_hash_header_start_.ClearToEmpty();
}
inline const std::string& getheaders::m_hash_header_start() const {
  // @@protoc_insertion_point(field_get:proto.getheaders.m_hash_header_start)
  return _internal_m_hash_header_start();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getheaders::set_m_hash_header_start(ArgT0&& arg0, ArgT... args) {
 
 m_hash_header_start_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.getheaders.m_hash_header_start)
}
inline std::string* getheaders::mutable_m_hash_header_start() {
  std::string* _s = _internal_mutable_m_hash_header_start();
  // @@protoc_insertion_point(field_mutable:proto.getheaders.m_hash_header_start)
  return _s;
}
inline const std::string& getheaders::_internal_m_hash_header_start() const {
  return m_hash_header_start_.Get();
}
inline void getheaders::_internal_set_m_hash_header_start(const std::string& value) {
  
  m_hash_header_start_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* getheaders::_internal_mutable_m_hash_header_start() {
  
  return m_hash_header_start_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* getheaders::release_m_hash_header_start() {
  // @@protoc_insertion_point(field_release:proto.getheaders.m_hash_header_start)
  return m_hash_header_start_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void getheaders::set_allocated_m_hash_header_start(std::string* m_hash_header_start) {
  if (m_hash_header_start != nullptr) {
    
  } else {
    
  }
  m_hash_header_start_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_hash_header_start,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_hash_header_start_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_hash_header_start_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.getheaders.m_hash_header_start)
}

// bytes m_hash_header_stop = 3;
inline void getheaders::clear_m_hash_header_stop() {
  m_hash_header_stop_.ClearToEmpty();
}
inline const std::string& getheaders::m_hash_header_stop() const {
  // @@protoc_insertion_point(field_get:proto.getheaders.m_hash_header_stop)
  return _internal_m_hash_header_stop();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getheaders::set_m_hash_header_stop(ArgT0&& arg0, ArgT... args) {
 
 m_hash_header_stop_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.getheaders.m_hash_header_stop)
}
inline std::string* getheaders::mutable_m_hash_header_stop() {
  std::string* _s = _internal_mutable_m_hash_header_stop();
  // @@protoc_insertion_point(field_mutable:proto.getheaders.m_hash_header_stop)
  return _s;
}
inline const std::string& getheaders::_internal_m_hash_header_stop() const {
  return m_hash_header_stop_.Get();
}
inline void getheaders::_internal_set_m_hash_header_stop(const std::string& value) {
  
  m_hash_header_stop_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* getheaders::_internal_mutable_m_hash_header_stop() {
  
  return m_hash_header_stop_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* getheaders::release_m_hash_header_stop() {
  // @@protoc_insertion_point(field_release:proto.getheaders.m_hash_header_stop)
  return m_hash_header_stop_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void getheaders::set_allocated_m_hash_header_stop(std::string* m_hash_header_stop) {
  if (m_hash_header_stop != nullptr) {
    
  } else {
    
  }
  m_hash_header_stop_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_hash_header_stop,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_hash_header_stop_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_hash_header_stop_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.getheaders.m_hash_header_stop)
}

// -------------------------------------------------------------------

// gettxs

// bytes m_hash_header = 1;
inline void gettxs::clear_m_hash_header() {
  m_hash_header_.ClearToEmpty();
}
inline const std::string& gettxs::m_hash_header() const {
  // @@protoc_insertion_point(field_get:proto.gettxs.m_hash_header)
  return _internal_m_hash_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void gettxs::set_m_hash_header(ArgT0&& arg0, ArgT... args) {
 
 m_hash_header_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.gettxs.m_hash_header)
}
inline std::string* gettxs::mutable_m_hash_header() {
  std::string* _s = _internal_mutable_m_hash_header();
  // @@protoc_insertion_point(field_mutable:proto.gettxs.m_hash_header)
  return _s;
}
inline const std::string& gettxs::_internal_m_hash_header() const {
  return m_hash_header_.Get();
}
inline void gettxs::_internal_set_m_hash_header(const std::string& value) {
  
  m_hash_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* gettxs::_internal_mutable_m_hash_header() {
  
  return m_hash_header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* gettxs::release_m_hash_header() {
  // @@protoc_insertion_point(field_release:proto.gettxs.m_hash_header)
  return m_hash_header_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void gettxs::set_allocated_m_hash_header(std::string* m_hash_header) {
  if (m_hash_header != nullptr) {
    
  } else {
    
  }
  m_hash_header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_hash_header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_hash_header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_hash_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.gettxs.m_hash_header)
}

// -------------------------------------------------------------------

// getblock

// bytes m_hash_header = 1;
inline void getblock::clear_m_hash_header() {
  m_hash_header_.ClearToEmpty();
}
inline const std::string& getblock::m_hash_header() const {
  // @@protoc_insertion_point(field_get:proto.getblock.m_hash_header)
  return _internal_m_hash_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getblock::set_m_hash_header(ArgT0&& arg0, ArgT... args) {
 
 m_hash_header_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.getblock.m_hash_header)
}
inline std::string* getblock::mutable_m_hash_header() {
  std::string* _s = _internal_mutable_m_hash_header();
  // @@protoc_insertion_point(field_mutable:proto.getblock.m_hash_header)
  return _s;
}
inline const std::string& getblock::_internal_m_hash_header() const {
  return m_hash_header_.Get();
}
inline void getblock::_internal_set_m_hash_header(const std::string& value) {
  
  m_hash_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* getblock::_internal_mutable_m_hash_header() {
  
  return m_hash_header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* getblock::release_m_hash_header() {
  // @@protoc_insertion_point(field_release:proto.getblock.m_hash_header)
  return m_hash_header_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void getblock::set_allocated_m_hash_header(std::string* m_hash_header) {
  if (m_hash_header != nullptr) {
    
  } else {
    
  }
  m_hash_header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_hash_header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_hash_header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_hash_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.getblock.m_hash_header)
}

// -------------------------------------------------------------------

// getmempooltransactions

// -------------------------------------------------------------------

// getaddr

// -------------------------------------------------------------------

// getmerklebranch

// bytes m_txid = 1;
inline void getmerklebranch::clear_m_txid() {
  m_txid_.ClearToEmpty();
}
inline const std::string& getmerklebranch::m_txid() const {
  // @@protoc_insertion_point(field_get:proto.getmerklebranch.m_txid)
  return _internal_m_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getmerklebranch::set_m_txid(ArgT0&& arg0, ArgT... args) {
 
 m_txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.getmerklebranch.m_txid)
}
inline std::string* getmerklebranch::mutable_m_txid() {
  std::string* _s = _internal_mutable_m_txid();
  // @@protoc_insertion_point(field_mutable:proto.getmerklebranch.m_txid)
  return _s;
}
inline const std::string& getmerklebranch::_internal_m_txid() const {
  return m_txid_.Get();
}
inline void getmerklebranch::_internal_set_m_txid(const std::string& value) {
  
  m_txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* getmerklebranch::_internal_mutable_m_txid() {
  
  return m_txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* getmerklebranch::release_m_txid() {
  // @@protoc_insertion_point(field_release:proto.getmerklebranch.m_txid)
  return m_txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void getmerklebranch::set_allocated_m_txid(std::string* m_txid) {
  if (m_txid != nullptr) {
    
  } else {
    
  }
  m_txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_txid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.getmerklebranch.m_txid)
}

// -------------------------------------------------------------------

// merkle_branch

// repeated bytes m_merkle_branch = 1;
inline int merkle_branch::_internal_m_merkle_branch_size() const {
  return m_merkle_branch_.size();
}
inline int merkle_branch::m_merkle_branch_size() const {
  return _internal_m_merkle_branch_size();
}
inline void merkle_branch::clear_m_merkle_branch() {
  m_merkle_branch_.Clear();
}
inline std::string* merkle_branch::add_m_merkle_branch() {
  std::string* _s = _internal_add_m_merkle_branch();
  // @@protoc_insertion_point(field_add_mutable:proto.merkle_branch.m_merkle_branch)
  return _s;
}
inline const std::string& merkle_branch::_internal_m_merkle_branch(int index) const {
  return m_merkle_branch_.Get(index);
}
inline const std::string& merkle_branch::m_merkle_branch(int index) const {
  // @@protoc_insertion_point(field_get:proto.merkle_branch.m_merkle_branch)
  return _internal_m_merkle_branch(index);
}
inline std::string* merkle_branch::mutable_m_merkle_branch(int index) {
  // @@protoc_insertion_point(field_mutable:proto.merkle_branch.m_merkle_branch)
  return m_merkle_branch_.Mutable(index);
}
inline void merkle_branch::set_m_merkle_branch(int index, const std::string& value) {
  m_merkle_branch_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.merkle_branch.m_merkle_branch)
}
inline void merkle_branch::set_m_merkle_branch(int index, std::string&& value) {
  m_merkle_branch_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.merkle_branch.m_merkle_branch)
}
inline void merkle_branch::set_m_merkle_branch(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  m_merkle_branch_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.merkle_branch.m_merkle_branch)
}
inline void merkle_branch::set_m_merkle_branch(int index, const void* value, size_t size) {
  m_merkle_branch_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.merkle_branch.m_merkle_branch)
}
inline std::string* merkle_branch::_internal_add_m_merkle_branch() {
  return m_merkle_branch_.Add();
}
inline void merkle_branch::add_m_merkle_branch(const std::string& value) {
  m_merkle_branch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.merkle_branch.m_merkle_branch)
}
inline void merkle_branch::add_m_merkle_branch(std::string&& value) {
  m_merkle_branch_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.merkle_branch.m_merkle_branch)
}
inline void merkle_branch::add_m_merkle_branch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  m_merkle_branch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.merkle_branch.m_merkle_branch)
}
inline void merkle_branch::add_m_merkle_branch(const void* value, size_t size) {
  m_merkle_branch_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.merkle_branch.m_merkle_branch)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
merkle_branch::m_merkle_branch() const {
  // @@protoc_insertion_point(field_list:proto.merkle_branch.m_merkle_branch)
  return m_merkle_branch_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
merkle_branch::mutable_m_merkle_branch() {
  // @@protoc_insertion_point(field_mutable_list:proto.merkle_branch.m_merkle_branch)
  return &m_merkle_branch_;
}

// optional bytes m_block_id = 2;
inline bool merkle_branch::_internal_has_m_block_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool merkle_branch::has_m_block_id() const {
  return _internal_has_m_block_id();
}
inline void merkle_branch::clear_m_block_id() {
  m_block_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& merkle_branch::m_block_id() const {
  // @@protoc_insertion_point(field_get:proto.merkle_branch.m_block_id)
  return _internal_m_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void merkle_branch::set_m_block_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 m_block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.merkle_branch.m_block_id)
}
inline std::string* merkle_branch::mutable_m_block_id() {
  std::string* _s = _internal_mutable_m_block_id();
  // @@protoc_insertion_point(field_mutable:proto.merkle_branch.m_block_id)
  return _s;
}
inline const std::string& merkle_branch::_internal_m_block_id() const {
  return m_block_id_.Get();
}
inline void merkle_branch::_internal_set_m_block_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  m_block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* merkle_branch::_internal_mutable_m_block_id() {
  _has_bits_[0] |= 0x00000001u;
  return m_block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* merkle_branch::release_m_block_id() {
  // @@protoc_insertion_point(field_release:proto.merkle_branch.m_block_id)
  if (!_internal_has_m_block_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = m_block_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_block_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_block_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void merkle_branch::set_allocated_m_block_id(std::string* m_block_id) {
  if (m_block_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  m_block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_block_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_block_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_block_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.merkle_branch.m_block_id)
}

// -------------------------------------------------------------------

// get_all_active_votings_for_voter

// bytes m_voter_pk = 1;
inline void get_all_active_votings_for_voter::clear_m_voter_pk() {
  m_voter_pk_.ClearToEmpty();
}
inline const std::string& get_all_active_votings_for_voter::m_voter_pk() const {
  // @@protoc_insertion_point(field_get:proto.get_all_active_votings_for_voter.m_voter_pk)
  return _internal_m_voter_pk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_all_active_votings_for_voter::set_m_voter_pk(ArgT0&& arg0, ArgT... args) {
 
 m_voter_pk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.get_all_active_votings_for_voter.m_voter_pk)
}
inline std::string* get_all_active_votings_for_voter::mutable_m_voter_pk() {
  std::string* _s = _internal_mutable_m_voter_pk();
  // @@protoc_insertion_point(field_mutable:proto.get_all_active_votings_for_voter.m_voter_pk)
  return _s;
}
inline const std::string& get_all_active_votings_for_voter::_internal_m_voter_pk() const {
  return m_voter_pk_.Get();
}
inline void get_all_active_votings_for_voter::_internal_set_m_voter_pk(const std::string& value) {
  
  m_voter_pk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_all_active_votings_for_voter::_internal_mutable_m_voter_pk() {
  
  return m_voter_pk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_all_active_votings_for_voter::release_m_voter_pk() {
  // @@protoc_insertion_point(field_release:proto.get_all_active_votings_for_voter.m_voter_pk)
  return m_voter_pk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_all_active_votings_for_voter::set_allocated_m_voter_pk(std::string* m_voter_pk) {
  if (m_voter_pk != nullptr) {
    
  } else {
    
  }
  m_voter_pk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_voter_pk,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_voter_pk_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_voter_pk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.get_all_active_votings_for_voter.m_voter_pk)
}

// -------------------------------------------------------------------

// get_amount_on_pkh

// bytes m_pkh = 1;
inline void get_amount_on_pkh::clear_m_pkh() {
  m_pkh_.ClearToEmpty();
}
inline const std::string& get_amount_on_pkh::m_pkh() const {
  // @@protoc_insertion_point(field_get:proto.get_amount_on_pkh.m_pkh)
  return _internal_m_pkh();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_amount_on_pkh::set_m_pkh(ArgT0&& arg0, ArgT... args) {
 
 m_pkh_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.get_amount_on_pkh.m_pkh)
}
inline std::string* get_amount_on_pkh::mutable_m_pkh() {
  std::string* _s = _internal_mutable_m_pkh();
  // @@protoc_insertion_point(field_mutable:proto.get_amount_on_pkh.m_pkh)
  return _s;
}
inline const std::string& get_amount_on_pkh::_internal_m_pkh() const {
  return m_pkh_.Get();
}
inline void get_amount_on_pkh::_internal_set_m_pkh(const std::string& value) {
  
  m_pkh_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_amount_on_pkh::_internal_mutable_m_pkh() {
  
  return m_pkh_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_amount_on_pkh::release_m_pkh() {
  // @@protoc_insertion_point(field_release:proto.get_amount_on_pkh.m_pkh)
  return m_pkh_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_amount_on_pkh::set_allocated_m_pkh(std::string* m_pkh) {
  if (m_pkh != nullptr) {
    
  } else {
    
  }
  m_pkh_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_pkh,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_pkh_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_pkh_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.get_amount_on_pkh.m_pkh)
}

// -------------------------------------------------------------------

// amount_on_pkh

// uint32 m_amount = 1;
inline void amount_on_pkh::clear_m_amount() {
  m_amount_ = 0u;
}
inline uint32_t amount_on_pkh::_internal_m_amount() const {
  return m_amount_;
}
inline uint32_t amount_on_pkh::m_amount() const {
  // @@protoc_insertion_point(field_get:proto.amount_on_pkh.m_amount)
  return _internal_m_amount();
}
inline void amount_on_pkh::_internal_set_m_amount(uint32_t value) {
  
  m_amount_ = value;
}
inline void amount_on_pkh::set_m_amount(uint32_t value) {
  _internal_set_m_amount(value);
  // @@protoc_insertion_point(field_set:proto.amount_on_pkh.m_amount)
}

// optional bytes m_txid = 2;
inline bool amount_on_pkh::_internal_has_m_txid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool amount_on_pkh::has_m_txid() const {
  return _internal_has_m_txid();
}
inline void amount_on_pkh::clear_m_txid() {
  m_txid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& amount_on_pkh::m_txid() const {
  // @@protoc_insertion_point(field_get:proto.amount_on_pkh.m_txid)
  return _internal_m_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void amount_on_pkh::set_m_txid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 m_txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.amount_on_pkh.m_txid)
}
inline std::string* amount_on_pkh::mutable_m_txid() {
  std::string* _s = _internal_mutable_m_txid();
  // @@protoc_insertion_point(field_mutable:proto.amount_on_pkh.m_txid)
  return _s;
}
inline const std::string& amount_on_pkh::_internal_m_txid() const {
  return m_txid_.Get();
}
inline void amount_on_pkh::_internal_set_m_txid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  m_txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* amount_on_pkh::_internal_mutable_m_txid() {
  _has_bits_[0] |= 0x00000001u;
  return m_txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* amount_on_pkh::release_m_txid() {
  // @@protoc_insertion_point(field_release:proto.amount_on_pkh.m_txid)
  if (!_internal_has_m_txid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = m_txid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void amount_on_pkh::set_allocated_m_txid(std::string* m_txid) {
  if (m_txid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  m_txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_txid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.amount_on_pkh.m_txid)
}

// -------------------------------------------------------------------

// get_transaction

// bytes m_txid = 1;
inline void get_transaction::clear_m_txid() {
  m_txid_.ClearToEmpty();
}
inline const std::string& get_transaction::m_txid() const {
  // @@protoc_insertion_point(field_get:proto.get_transaction.m_txid)
  return _internal_m_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_transaction::set_m_txid(ArgT0&& arg0, ArgT... args) {
 
 m_txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.get_transaction.m_txid)
}
inline std::string* get_transaction::mutable_m_txid() {
  std::string* _s = _internal_mutable_m_txid();
  // @@protoc_insertion_point(field_mutable:proto.get_transaction.m_txid)
  return _s;
}
inline const std::string& get_transaction::_internal_m_txid() const {
  return m_txid_.Get();
}
inline void get_transaction::_internal_set_m_txid(const std::string& value) {
  
  m_txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_transaction::_internal_mutable_m_txid() {
  
  return m_txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_transaction::release_m_txid() {
  // @@protoc_insertion_point(field_release:proto.get_transaction.m_txid)
  return m_txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_transaction::set_allocated_m_txid(std::string* m_txid) {
  if (m_txid != nullptr) {
    
  } else {
    
  }
  m_txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_txid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.get_transaction.m_txid)
}

// -------------------------------------------------------------------

// get_authorization_txid

// bytes m_pk = 1;
inline void get_authorization_txid::clear_m_pk() {
  m_pk_.ClearToEmpty();
}
inline const std::string& get_authorization_txid::m_pk() const {
  // @@protoc_insertion_point(field_get:proto.get_authorization_txid.m_pk)
  return _internal_m_pk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_authorization_txid::set_m_pk(ArgT0&& arg0, ArgT... args) {
 
 m_pk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.get_authorization_txid.m_pk)
}
inline std::string* get_authorization_txid::mutable_m_pk() {
  std::string* _s = _internal_mutable_m_pk();
  // @@protoc_insertion_point(field_mutable:proto.get_authorization_txid.m_pk)
  return _s;
}
inline const std::string& get_authorization_txid::_internal_m_pk() const {
  return m_pk_.Get();
}
inline void get_authorization_txid::_internal_set_m_pk(const std::string& value) {
  
  m_pk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_authorization_txid::_internal_mutable_m_pk() {
  
  return m_pk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_authorization_txid::release_m_pk() {
  // @@protoc_insertion_point(field_release:proto.get_authorization_txid.m_pk)
  return m_pk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_authorization_txid::set_allocated_m_pk(std::string* m_pk) {
  if (m_pk != nullptr) {
    
  } else {
    
  }
  m_pk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_pk,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_pk_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_pk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.get_authorization_txid.m_pk)
}

// bytes m_voting_id = 2;
inline void get_authorization_txid::clear_m_voting_id() {
  m_voting_id_.ClearToEmpty();
}
inline const std::string& get_authorization_txid::m_voting_id() const {
  // @@protoc_insertion_point(field_get:proto.get_authorization_txid.m_voting_id)
  return _internal_m_voting_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_authorization_txid::set_m_voting_id(ArgT0&& arg0, ArgT... args) {
 
 m_voting_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.get_authorization_txid.m_voting_id)
}
inline std::string* get_authorization_txid::mutable_m_voting_id() {
  std::string* _s = _internal_mutable_m_voting_id();
  // @@protoc_insertion_point(field_mutable:proto.get_authorization_txid.m_voting_id)
  return _s;
}
inline const std::string& get_authorization_txid::_internal_m_voting_id() const {
  return m_voting_id_.Get();
}
inline void get_authorization_txid::_internal_set_m_voting_id(const std::string& value) {
  
  m_voting_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_authorization_txid::_internal_mutable_m_voting_id() {
  
  return m_voting_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_authorization_txid::release_m_voting_id() {
  // @@protoc_insertion_point(field_release:proto.get_authorization_txid.m_voting_id)
  return m_voting_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_authorization_txid::set_allocated_m_voting_id(std::string* m_voting_id) {
  if (m_voting_id != nullptr) {
    
  } else {
    
  }
  m_voting_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_voting_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_voting_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_voting_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.get_authorization_txid.m_voting_id)
}

// -------------------------------------------------------------------

// authorization_txid

// bytes m_txid = 1;
inline void authorization_txid::clear_m_txid() {
  m_txid_.ClearToEmpty();
}
inline const std::string& authorization_txid::m_txid() const {
  // @@protoc_insertion_point(field_get:proto.authorization_txid.m_txid)
  return _internal_m_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void authorization_txid::set_m_txid(ArgT0&& arg0, ArgT... args) {
 
 m_txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.authorization_txid.m_txid)
}
inline std::string* authorization_txid::mutable_m_txid() {
  std::string* _s = _internal_mutable_m_txid();
  // @@protoc_insertion_point(field_mutable:proto.authorization_txid.m_txid)
  return _s;
}
inline const std::string& authorization_txid::_internal_m_txid() const {
  return m_txid_.Get();
}
inline void authorization_txid::_internal_set_m_txid(const std::string& value) {
  
  m_txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* authorization_txid::_internal_mutable_m_txid() {
  
  return m_txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* authorization_txid::release_m_txid() {
  // @@protoc_insertion_point(field_release:proto.authorization_txid.m_txid)
  return m_txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void authorization_txid::set_allocated_m_txid(std::string* m_txid) {
  if (m_txid != nullptr) {
    
  } else {
    
  }
  m_txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_txid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.authorization_txid.m_txid)
}

// -------------------------------------------------------------------

// get_all_finished_votings_for_voter

// bytes m_voter_pk = 1;
inline void get_all_finished_votings_for_voter::clear_m_voter_pk() {
  m_voter_pk_.ClearToEmpty();
}
inline const std::string& get_all_finished_votings_for_voter::m_voter_pk() const {
  // @@protoc_insertion_point(field_get:proto.get_all_finished_votings_for_voter.m_voter_pk)
  return _internal_m_voter_pk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_all_finished_votings_for_voter::set_m_voter_pk(ArgT0&& arg0, ArgT... args) {
 
 m_voter_pk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.get_all_finished_votings_for_voter.m_voter_pk)
}
inline std::string* get_all_finished_votings_for_voter::mutable_m_voter_pk() {
  std::string* _s = _internal_mutable_m_voter_pk();
  // @@protoc_insertion_point(field_mutable:proto.get_all_finished_votings_for_voter.m_voter_pk)
  return _s;
}
inline const std::string& get_all_finished_votings_for_voter::_internal_m_voter_pk() const {
  return m_voter_pk_.Get();
}
inline void get_all_finished_votings_for_voter::_internal_set_m_voter_pk(const std::string& value) {
  
  m_voter_pk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_all_finished_votings_for_voter::_internal_mutable_m_voter_pk() {
  
  return m_voter_pk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_all_finished_votings_for_voter::release_m_voter_pk() {
  // @@protoc_insertion_point(field_release:proto.get_all_finished_votings_for_voter.m_voter_pk)
  return m_voter_pk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_all_finished_votings_for_voter::set_allocated_m_voter_pk(std::string* m_voter_pk) {
  if (m_voter_pk != nullptr) {
    
  } else {
    
  }
  m_voter_pk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_voter_pk,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (m_voter_pk_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    m_voter_pk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.get_all_finished_votings_for_voter.m_voter_pk)
}

// -------------------------------------------------------------------

// all_finished_votings_for_voter

// repeated bytes m_voting_ids = 1;
inline int all_finished_votings_for_voter::_internal_m_voting_ids_size() const {
  return m_voting_ids_.size();
}
inline int all_finished_votings_for_voter::m_voting_ids_size() const {
  return _internal_m_voting_ids_size();
}
inline void all_finished_votings_for_voter::clear_m_voting_ids() {
  m_voting_ids_.Clear();
}
inline std::string* all_finished_votings_for_voter::add_m_voting_ids() {
  std::string* _s = _internal_add_m_voting_ids();
  // @@protoc_insertion_point(field_add_mutable:proto.all_finished_votings_for_voter.m_voting_ids)
  return _s;
}
inline const std::string& all_finished_votings_for_voter::_internal_m_voting_ids(int index) const {
  return m_voting_ids_.Get(index);
}
inline const std::string& all_finished_votings_for_voter::m_voting_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.all_finished_votings_for_voter.m_voting_ids)
  return _internal_m_voting_ids(index);
}
inline std::string* all_finished_votings_for_voter::mutable_m_voting_ids(int index) {
  // @@protoc_insertion_point(field_mutable:proto.all_finished_votings_for_voter.m_voting_ids)
  return m_voting_ids_.Mutable(index);
}
inline void all_finished_votings_for_voter::set_m_voting_ids(int index, const std::string& value) {
  m_voting_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.all_finished_votings_for_voter.m_voting_ids)
}
inline void all_finished_votings_for_voter::set_m_voting_ids(int index, std::string&& value) {
  m_voting_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.all_finished_votings_for_voter.m_voting_ids)
}
inline void all_finished_votings_for_voter::set_m_voting_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  m_voting_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.all_finished_votings_for_voter.m_voting_ids)
}
inline void all_finished_votings_for_voter::set_m_voting_ids(int index, const void* value, size_t size) {
  m_voting_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.all_finished_votings_for_voter.m_voting_ids)
}
inline std::string* all_finished_votings_for_voter::_internal_add_m_voting_ids() {
  return m_voting_ids_.Add();
}
inline void all_finished_votings_for_voter::add_m_voting_ids(const std::string& value) {
  m_voting_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.all_finished_votings_for_voter.m_voting_ids)
}
inline void all_finished_votings_for_voter::add_m_voting_ids(std::string&& value) {
  m_voting_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.all_finished_votings_for_voter.m_voting_ids)
}
inline void all_finished_votings_for_voter::add_m_voting_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  m_voting_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.all_finished_votings_for_voter.m_voting_ids)
}
inline void all_finished_votings_for_voter::add_m_voting_ids(const void* value, size_t size) {
  m_voting_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.all_finished_votings_for_voter.m_voting_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
all_finished_votings_for_voter::m_voting_ids() const {
  // @@protoc_insertion_point(field_list:proto.all_finished_votings_for_voter.m_voting_ids)
  return m_voting_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
all_finished_votings_for_voter::mutable_m_voting_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.all_finished_votings_for_voter.m_voting_ids)
  return &m_voting_ids_;
}

// -------------------------------------------------------------------

// request

// .proto.getheaders m_getheaders = 1;
inline bool request::_internal_has_m_getheaders() const {
  return request_type_case() == kMGetheaders;
}
inline bool request::has_m_getheaders() const {
  return _internal_has_m_getheaders();
}
inline void request::set_has_m_getheaders() {
  _oneof_case_[0] = kMGetheaders;
}
inline void request::clear_m_getheaders() {
  if (_internal_has_m_getheaders()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_getheaders_;
    }
    clear_has_request_type();
  }
}
inline ::proto::getheaders* request::release_m_getheaders() {
  // @@protoc_insertion_point(field_release:proto.request.m_getheaders)
  if (_internal_has_m_getheaders()) {
    clear_has_request_type();
      ::proto::getheaders* temp = request_type_.m_getheaders_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_getheaders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::getheaders& request::_internal_m_getheaders() const {
  return _internal_has_m_getheaders()
      ? *request_type_.m_getheaders_
      : reinterpret_cast< ::proto::getheaders&>(::proto::_getheaders_default_instance_);
}
inline const ::proto::getheaders& request::m_getheaders() const {
  // @@protoc_insertion_point(field_get:proto.request.m_getheaders)
  return _internal_m_getheaders();
}
inline ::proto::getheaders* request::unsafe_arena_release_m_getheaders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_getheaders)
  if (_internal_has_m_getheaders()) {
    clear_has_request_type();
    ::proto::getheaders* temp = request_type_.m_getheaders_;
    request_type_.m_getheaders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_getheaders(::proto::getheaders* m_getheaders) {
  clear_request_type();
  if (m_getheaders) {
    set_has_m_getheaders();
    request_type_.m_getheaders_ = m_getheaders;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_getheaders)
}
inline ::proto::getheaders* request::_internal_mutable_m_getheaders() {
  if (!_internal_has_m_getheaders()) {
    clear_request_type();
    set_has_m_getheaders();
    request_type_.m_getheaders_ = CreateMaybeMessage< ::proto::getheaders >(GetArenaForAllocation());
  }
  return request_type_.m_getheaders_;
}
inline ::proto::getheaders* request::mutable_m_getheaders() {
  ::proto::getheaders* _msg = _internal_mutable_m_getheaders();
  // @@protoc_insertion_point(field_mutable:proto.request.m_getheaders)
  return _msg;
}

// .proto.gettxs m_gettxs = 2;
inline bool request::_internal_has_m_gettxs() const {
  return request_type_case() == kMGettxs;
}
inline bool request::has_m_gettxs() const {
  return _internal_has_m_gettxs();
}
inline void request::set_has_m_gettxs() {
  _oneof_case_[0] = kMGettxs;
}
inline void request::clear_m_gettxs() {
  if (_internal_has_m_gettxs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_gettxs_;
    }
    clear_has_request_type();
  }
}
inline ::proto::gettxs* request::release_m_gettxs() {
  // @@protoc_insertion_point(field_release:proto.request.m_gettxs)
  if (_internal_has_m_gettxs()) {
    clear_has_request_type();
      ::proto::gettxs* temp = request_type_.m_gettxs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_gettxs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::gettxs& request::_internal_m_gettxs() const {
  return _internal_has_m_gettxs()
      ? *request_type_.m_gettxs_
      : reinterpret_cast< ::proto::gettxs&>(::proto::_gettxs_default_instance_);
}
inline const ::proto::gettxs& request::m_gettxs() const {
  // @@protoc_insertion_point(field_get:proto.request.m_gettxs)
  return _internal_m_gettxs();
}
inline ::proto::gettxs* request::unsafe_arena_release_m_gettxs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_gettxs)
  if (_internal_has_m_gettxs()) {
    clear_has_request_type();
    ::proto::gettxs* temp = request_type_.m_gettxs_;
    request_type_.m_gettxs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_gettxs(::proto::gettxs* m_gettxs) {
  clear_request_type();
  if (m_gettxs) {
    set_has_m_gettxs();
    request_type_.m_gettxs_ = m_gettxs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_gettxs)
}
inline ::proto::gettxs* request::_internal_mutable_m_gettxs() {
  if (!_internal_has_m_gettxs()) {
    clear_request_type();
    set_has_m_gettxs();
    request_type_.m_gettxs_ = CreateMaybeMessage< ::proto::gettxs >(GetArenaForAllocation());
  }
  return request_type_.m_gettxs_;
}
inline ::proto::gettxs* request::mutable_m_gettxs() {
  ::proto::gettxs* _msg = _internal_mutable_m_gettxs();
  // @@protoc_insertion_point(field_mutable:proto.request.m_gettxs)
  return _msg;
}

// .proto.getblock m_getblock = 3;
inline bool request::_internal_has_m_getblock() const {
  return request_type_case() == kMGetblock;
}
inline bool request::has_m_getblock() const {
  return _internal_has_m_getblock();
}
inline void request::set_has_m_getblock() {
  _oneof_case_[0] = kMGetblock;
}
inline void request::clear_m_getblock() {
  if (_internal_has_m_getblock()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_getblock_;
    }
    clear_has_request_type();
  }
}
inline ::proto::getblock* request::release_m_getblock() {
  // @@protoc_insertion_point(field_release:proto.request.m_getblock)
  if (_internal_has_m_getblock()) {
    clear_has_request_type();
      ::proto::getblock* temp = request_type_.m_getblock_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_getblock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::getblock& request::_internal_m_getblock() const {
  return _internal_has_m_getblock()
      ? *request_type_.m_getblock_
      : reinterpret_cast< ::proto::getblock&>(::proto::_getblock_default_instance_);
}
inline const ::proto::getblock& request::m_getblock() const {
  // @@protoc_insertion_point(field_get:proto.request.m_getblock)
  return _internal_m_getblock();
}
inline ::proto::getblock* request::unsafe_arena_release_m_getblock() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_getblock)
  if (_internal_has_m_getblock()) {
    clear_has_request_type();
    ::proto::getblock* temp = request_type_.m_getblock_;
    request_type_.m_getblock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_getblock(::proto::getblock* m_getblock) {
  clear_request_type();
  if (m_getblock) {
    set_has_m_getblock();
    request_type_.m_getblock_ = m_getblock;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_getblock)
}
inline ::proto::getblock* request::_internal_mutable_m_getblock() {
  if (!_internal_has_m_getblock()) {
    clear_request_type();
    set_has_m_getblock();
    request_type_.m_getblock_ = CreateMaybeMessage< ::proto::getblock >(GetArenaForAllocation());
  }
  return request_type_.m_getblock_;
}
inline ::proto::getblock* request::mutable_m_getblock() {
  ::proto::getblock* _msg = _internal_mutable_m_getblock();
  // @@protoc_insertion_point(field_mutable:proto.request.m_getblock)
  return _msg;
}

// .proto.getmempooltransactions m_getmempooltransactions = 4;
inline bool request::_internal_has_m_getmempooltransactions() const {
  return request_type_case() == kMGetmempooltransactions;
}
inline bool request::has_m_getmempooltransactions() const {
  return _internal_has_m_getmempooltransactions();
}
inline void request::set_has_m_getmempooltransactions() {
  _oneof_case_[0] = kMGetmempooltransactions;
}
inline void request::clear_m_getmempooltransactions() {
  if (_internal_has_m_getmempooltransactions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_getmempooltransactions_;
    }
    clear_has_request_type();
  }
}
inline ::proto::getmempooltransactions* request::release_m_getmempooltransactions() {
  // @@protoc_insertion_point(field_release:proto.request.m_getmempooltransactions)
  if (_internal_has_m_getmempooltransactions()) {
    clear_has_request_type();
      ::proto::getmempooltransactions* temp = request_type_.m_getmempooltransactions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_getmempooltransactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::getmempooltransactions& request::_internal_m_getmempooltransactions() const {
  return _internal_has_m_getmempooltransactions()
      ? *request_type_.m_getmempooltransactions_
      : reinterpret_cast< ::proto::getmempooltransactions&>(::proto::_getmempooltransactions_default_instance_);
}
inline const ::proto::getmempooltransactions& request::m_getmempooltransactions() const {
  // @@protoc_insertion_point(field_get:proto.request.m_getmempooltransactions)
  return _internal_m_getmempooltransactions();
}
inline ::proto::getmempooltransactions* request::unsafe_arena_release_m_getmempooltransactions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_getmempooltransactions)
  if (_internal_has_m_getmempooltransactions()) {
    clear_has_request_type();
    ::proto::getmempooltransactions* temp = request_type_.m_getmempooltransactions_;
    request_type_.m_getmempooltransactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_getmempooltransactions(::proto::getmempooltransactions* m_getmempooltransactions) {
  clear_request_type();
  if (m_getmempooltransactions) {
    set_has_m_getmempooltransactions();
    request_type_.m_getmempooltransactions_ = m_getmempooltransactions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_getmempooltransactions)
}
inline ::proto::getmempooltransactions* request::_internal_mutable_m_getmempooltransactions() {
  if (!_internal_has_m_getmempooltransactions()) {
    clear_request_type();
    set_has_m_getmempooltransactions();
    request_type_.m_getmempooltransactions_ = CreateMaybeMessage< ::proto::getmempooltransactions >(GetArenaForAllocation());
  }
  return request_type_.m_getmempooltransactions_;
}
inline ::proto::getmempooltransactions* request::mutable_m_getmempooltransactions() {
  ::proto::getmempooltransactions* _msg = _internal_mutable_m_getmempooltransactions();
  // @@protoc_insertion_point(field_mutable:proto.request.m_getmempooltransactions)
  return _msg;
}

// .proto.getaddr m_getaddr = 5;
inline bool request::_internal_has_m_getaddr() const {
  return request_type_case() == kMGetaddr;
}
inline bool request::has_m_getaddr() const {
  return _internal_has_m_getaddr();
}
inline void request::set_has_m_getaddr() {
  _oneof_case_[0] = kMGetaddr;
}
inline void request::clear_m_getaddr() {
  if (_internal_has_m_getaddr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_getaddr_;
    }
    clear_has_request_type();
  }
}
inline ::proto::getaddr* request::release_m_getaddr() {
  // @@protoc_insertion_point(field_release:proto.request.m_getaddr)
  if (_internal_has_m_getaddr()) {
    clear_has_request_type();
      ::proto::getaddr* temp = request_type_.m_getaddr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_getaddr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::getaddr& request::_internal_m_getaddr() const {
  return _internal_has_m_getaddr()
      ? *request_type_.m_getaddr_
      : reinterpret_cast< ::proto::getaddr&>(::proto::_getaddr_default_instance_);
}
inline const ::proto::getaddr& request::m_getaddr() const {
  // @@protoc_insertion_point(field_get:proto.request.m_getaddr)
  return _internal_m_getaddr();
}
inline ::proto::getaddr* request::unsafe_arena_release_m_getaddr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_getaddr)
  if (_internal_has_m_getaddr()) {
    clear_has_request_type();
    ::proto::getaddr* temp = request_type_.m_getaddr_;
    request_type_.m_getaddr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_getaddr(::proto::getaddr* m_getaddr) {
  clear_request_type();
  if (m_getaddr) {
    set_has_m_getaddr();
    request_type_.m_getaddr_ = m_getaddr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_getaddr)
}
inline ::proto::getaddr* request::_internal_mutable_m_getaddr() {
  if (!_internal_has_m_getaddr()) {
    clear_request_type();
    set_has_m_getaddr();
    request_type_.m_getaddr_ = CreateMaybeMessage< ::proto::getaddr >(GetArenaForAllocation());
  }
  return request_type_.m_getaddr_;
}
inline ::proto::getaddr* request::mutable_m_getaddr() {
  ::proto::getaddr* _msg = _internal_mutable_m_getaddr();
  // @@protoc_insertion_point(field_mutable:proto.request.m_getaddr)
  return _msg;
}

// .proto.getmerklebranch m_getmerklebranch = 6;
inline bool request::_internal_has_m_getmerklebranch() const {
  return request_type_case() == kMGetmerklebranch;
}
inline bool request::has_m_getmerklebranch() const {
  return _internal_has_m_getmerklebranch();
}
inline void request::set_has_m_getmerklebranch() {
  _oneof_case_[0] = kMGetmerklebranch;
}
inline void request::clear_m_getmerklebranch() {
  if (_internal_has_m_getmerklebranch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_getmerklebranch_;
    }
    clear_has_request_type();
  }
}
inline ::proto::getmerklebranch* request::release_m_getmerklebranch() {
  // @@protoc_insertion_point(field_release:proto.request.m_getmerklebranch)
  if (_internal_has_m_getmerklebranch()) {
    clear_has_request_type();
      ::proto::getmerklebranch* temp = request_type_.m_getmerklebranch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_getmerklebranch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::getmerklebranch& request::_internal_m_getmerklebranch() const {
  return _internal_has_m_getmerklebranch()
      ? *request_type_.m_getmerklebranch_
      : reinterpret_cast< ::proto::getmerklebranch&>(::proto::_getmerklebranch_default_instance_);
}
inline const ::proto::getmerklebranch& request::m_getmerklebranch() const {
  // @@protoc_insertion_point(field_get:proto.request.m_getmerklebranch)
  return _internal_m_getmerklebranch();
}
inline ::proto::getmerklebranch* request::unsafe_arena_release_m_getmerklebranch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_getmerklebranch)
  if (_internal_has_m_getmerklebranch()) {
    clear_has_request_type();
    ::proto::getmerklebranch* temp = request_type_.m_getmerklebranch_;
    request_type_.m_getmerklebranch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_getmerklebranch(::proto::getmerklebranch* m_getmerklebranch) {
  clear_request_type();
  if (m_getmerklebranch) {
    set_has_m_getmerklebranch();
    request_type_.m_getmerklebranch_ = m_getmerklebranch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_getmerklebranch)
}
inline ::proto::getmerklebranch* request::_internal_mutable_m_getmerklebranch() {
  if (!_internal_has_m_getmerklebranch()) {
    clear_request_type();
    set_has_m_getmerklebranch();
    request_type_.m_getmerklebranch_ = CreateMaybeMessage< ::proto::getmerklebranch >(GetArenaForAllocation());
  }
  return request_type_.m_getmerklebranch_;
}
inline ::proto::getmerklebranch* request::mutable_m_getmerklebranch() {
  ::proto::getmerklebranch* _msg = _internal_mutable_m_getmerklebranch();
  // @@protoc_insertion_point(field_mutable:proto.request.m_getmerklebranch)
  return _msg;
}

// .proto.get_all_active_votings_for_voter m_get_all_active_votings_for_voter = 8;
inline bool request::_internal_has_m_get_all_active_votings_for_voter() const {
  return request_type_case() == kMGetAllActiveVotingsForVoter;
}
inline bool request::has_m_get_all_active_votings_for_voter() const {
  return _internal_has_m_get_all_active_votings_for_voter();
}
inline void request::set_has_m_get_all_active_votings_for_voter() {
  _oneof_case_[0] = kMGetAllActiveVotingsForVoter;
}
inline void request::clear_m_get_all_active_votings_for_voter() {
  if (_internal_has_m_get_all_active_votings_for_voter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_get_all_active_votings_for_voter_;
    }
    clear_has_request_type();
  }
}
inline ::proto::get_all_active_votings_for_voter* request::release_m_get_all_active_votings_for_voter() {
  // @@protoc_insertion_point(field_release:proto.request.m_get_all_active_votings_for_voter)
  if (_internal_has_m_get_all_active_votings_for_voter()) {
    clear_has_request_type();
      ::proto::get_all_active_votings_for_voter* temp = request_type_.m_get_all_active_votings_for_voter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_get_all_active_votings_for_voter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::get_all_active_votings_for_voter& request::_internal_m_get_all_active_votings_for_voter() const {
  return _internal_has_m_get_all_active_votings_for_voter()
      ? *request_type_.m_get_all_active_votings_for_voter_
      : reinterpret_cast< ::proto::get_all_active_votings_for_voter&>(::proto::_get_all_active_votings_for_voter_default_instance_);
}
inline const ::proto::get_all_active_votings_for_voter& request::m_get_all_active_votings_for_voter() const {
  // @@protoc_insertion_point(field_get:proto.request.m_get_all_active_votings_for_voter)
  return _internal_m_get_all_active_votings_for_voter();
}
inline ::proto::get_all_active_votings_for_voter* request::unsafe_arena_release_m_get_all_active_votings_for_voter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_get_all_active_votings_for_voter)
  if (_internal_has_m_get_all_active_votings_for_voter()) {
    clear_has_request_type();
    ::proto::get_all_active_votings_for_voter* temp = request_type_.m_get_all_active_votings_for_voter_;
    request_type_.m_get_all_active_votings_for_voter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_get_all_active_votings_for_voter(::proto::get_all_active_votings_for_voter* m_get_all_active_votings_for_voter) {
  clear_request_type();
  if (m_get_all_active_votings_for_voter) {
    set_has_m_get_all_active_votings_for_voter();
    request_type_.m_get_all_active_votings_for_voter_ = m_get_all_active_votings_for_voter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_get_all_active_votings_for_voter)
}
inline ::proto::get_all_active_votings_for_voter* request::_internal_mutable_m_get_all_active_votings_for_voter() {
  if (!_internal_has_m_get_all_active_votings_for_voter()) {
    clear_request_type();
    set_has_m_get_all_active_votings_for_voter();
    request_type_.m_get_all_active_votings_for_voter_ = CreateMaybeMessage< ::proto::get_all_active_votings_for_voter >(GetArenaForAllocation());
  }
  return request_type_.m_get_all_active_votings_for_voter_;
}
inline ::proto::get_all_active_votings_for_voter* request::mutable_m_get_all_active_votings_for_voter() {
  ::proto::get_all_active_votings_for_voter* _msg = _internal_mutable_m_get_all_active_votings_for_voter();
  // @@protoc_insertion_point(field_mutable:proto.request.m_get_all_active_votings_for_voter)
  return _msg;
}

// .proto.get_amount_on_pkh m_get_amount_on_pkh = 9;
inline bool request::_internal_has_m_get_amount_on_pkh() const {
  return request_type_case() == kMGetAmountOnPkh;
}
inline bool request::has_m_get_amount_on_pkh() const {
  return _internal_has_m_get_amount_on_pkh();
}
inline void request::set_has_m_get_amount_on_pkh() {
  _oneof_case_[0] = kMGetAmountOnPkh;
}
inline void request::clear_m_get_amount_on_pkh() {
  if (_internal_has_m_get_amount_on_pkh()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_get_amount_on_pkh_;
    }
    clear_has_request_type();
  }
}
inline ::proto::get_amount_on_pkh* request::release_m_get_amount_on_pkh() {
  // @@protoc_insertion_point(field_release:proto.request.m_get_amount_on_pkh)
  if (_internal_has_m_get_amount_on_pkh()) {
    clear_has_request_type();
      ::proto::get_amount_on_pkh* temp = request_type_.m_get_amount_on_pkh_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_get_amount_on_pkh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::get_amount_on_pkh& request::_internal_m_get_amount_on_pkh() const {
  return _internal_has_m_get_amount_on_pkh()
      ? *request_type_.m_get_amount_on_pkh_
      : reinterpret_cast< ::proto::get_amount_on_pkh&>(::proto::_get_amount_on_pkh_default_instance_);
}
inline const ::proto::get_amount_on_pkh& request::m_get_amount_on_pkh() const {
  // @@protoc_insertion_point(field_get:proto.request.m_get_amount_on_pkh)
  return _internal_m_get_amount_on_pkh();
}
inline ::proto::get_amount_on_pkh* request::unsafe_arena_release_m_get_amount_on_pkh() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_get_amount_on_pkh)
  if (_internal_has_m_get_amount_on_pkh()) {
    clear_has_request_type();
    ::proto::get_amount_on_pkh* temp = request_type_.m_get_amount_on_pkh_;
    request_type_.m_get_amount_on_pkh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_get_amount_on_pkh(::proto::get_amount_on_pkh* m_get_amount_on_pkh) {
  clear_request_type();
  if (m_get_amount_on_pkh) {
    set_has_m_get_amount_on_pkh();
    request_type_.m_get_amount_on_pkh_ = m_get_amount_on_pkh;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_get_amount_on_pkh)
}
inline ::proto::get_amount_on_pkh* request::_internal_mutable_m_get_amount_on_pkh() {
  if (!_internal_has_m_get_amount_on_pkh()) {
    clear_request_type();
    set_has_m_get_amount_on_pkh();
    request_type_.m_get_amount_on_pkh_ = CreateMaybeMessage< ::proto::get_amount_on_pkh >(GetArenaForAllocation());
  }
  return request_type_.m_get_amount_on_pkh_;
}
inline ::proto::get_amount_on_pkh* request::mutable_m_get_amount_on_pkh() {
  ::proto::get_amount_on_pkh* _msg = _internal_mutable_m_get_amount_on_pkh();
  // @@protoc_insertion_point(field_mutable:proto.request.m_get_amount_on_pkh)
  return _msg;
}

// .proto.get_transaction m_get_transaction = 10;
inline bool request::_internal_has_m_get_transaction() const {
  return request_type_case() == kMGetTransaction;
}
inline bool request::has_m_get_transaction() const {
  return _internal_has_m_get_transaction();
}
inline void request::set_has_m_get_transaction() {
  _oneof_case_[0] = kMGetTransaction;
}
inline void request::clear_m_get_transaction() {
  if (_internal_has_m_get_transaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_get_transaction_;
    }
    clear_has_request_type();
  }
}
inline ::proto::get_transaction* request::release_m_get_transaction() {
  // @@protoc_insertion_point(field_release:proto.request.m_get_transaction)
  if (_internal_has_m_get_transaction()) {
    clear_has_request_type();
      ::proto::get_transaction* temp = request_type_.m_get_transaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_get_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::get_transaction& request::_internal_m_get_transaction() const {
  return _internal_has_m_get_transaction()
      ? *request_type_.m_get_transaction_
      : reinterpret_cast< ::proto::get_transaction&>(::proto::_get_transaction_default_instance_);
}
inline const ::proto::get_transaction& request::m_get_transaction() const {
  // @@protoc_insertion_point(field_get:proto.request.m_get_transaction)
  return _internal_m_get_transaction();
}
inline ::proto::get_transaction* request::unsafe_arena_release_m_get_transaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_get_transaction)
  if (_internal_has_m_get_transaction()) {
    clear_has_request_type();
    ::proto::get_transaction* temp = request_type_.m_get_transaction_;
    request_type_.m_get_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_get_transaction(::proto::get_transaction* m_get_transaction) {
  clear_request_type();
  if (m_get_transaction) {
    set_has_m_get_transaction();
    request_type_.m_get_transaction_ = m_get_transaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_get_transaction)
}
inline ::proto::get_transaction* request::_internal_mutable_m_get_transaction() {
  if (!_internal_has_m_get_transaction()) {
    clear_request_type();
    set_has_m_get_transaction();
    request_type_.m_get_transaction_ = CreateMaybeMessage< ::proto::get_transaction >(GetArenaForAllocation());
  }
  return request_type_.m_get_transaction_;
}
inline ::proto::get_transaction* request::mutable_m_get_transaction() {
  ::proto::get_transaction* _msg = _internal_mutable_m_get_transaction();
  // @@protoc_insertion_point(field_mutable:proto.request.m_get_transaction)
  return _msg;
}

// .proto.get_authorization_txid m_get_authorization_txid = 11;
inline bool request::_internal_has_m_get_authorization_txid() const {
  return request_type_case() == kMGetAuthorizationTxid;
}
inline bool request::has_m_get_authorization_txid() const {
  return _internal_has_m_get_authorization_txid();
}
inline void request::set_has_m_get_authorization_txid() {
  _oneof_case_[0] = kMGetAuthorizationTxid;
}
inline void request::clear_m_get_authorization_txid() {
  if (_internal_has_m_get_authorization_txid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_get_authorization_txid_;
    }
    clear_has_request_type();
  }
}
inline ::proto::get_authorization_txid* request::release_m_get_authorization_txid() {
  // @@protoc_insertion_point(field_release:proto.request.m_get_authorization_txid)
  if (_internal_has_m_get_authorization_txid()) {
    clear_has_request_type();
      ::proto::get_authorization_txid* temp = request_type_.m_get_authorization_txid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_get_authorization_txid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::get_authorization_txid& request::_internal_m_get_authorization_txid() const {
  return _internal_has_m_get_authorization_txid()
      ? *request_type_.m_get_authorization_txid_
      : reinterpret_cast< ::proto::get_authorization_txid&>(::proto::_get_authorization_txid_default_instance_);
}
inline const ::proto::get_authorization_txid& request::m_get_authorization_txid() const {
  // @@protoc_insertion_point(field_get:proto.request.m_get_authorization_txid)
  return _internal_m_get_authorization_txid();
}
inline ::proto::get_authorization_txid* request::unsafe_arena_release_m_get_authorization_txid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_get_authorization_txid)
  if (_internal_has_m_get_authorization_txid()) {
    clear_has_request_type();
    ::proto::get_authorization_txid* temp = request_type_.m_get_authorization_txid_;
    request_type_.m_get_authorization_txid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_get_authorization_txid(::proto::get_authorization_txid* m_get_authorization_txid) {
  clear_request_type();
  if (m_get_authorization_txid) {
    set_has_m_get_authorization_txid();
    request_type_.m_get_authorization_txid_ = m_get_authorization_txid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_get_authorization_txid)
}
inline ::proto::get_authorization_txid* request::_internal_mutable_m_get_authorization_txid() {
  if (!_internal_has_m_get_authorization_txid()) {
    clear_request_type();
    set_has_m_get_authorization_txid();
    request_type_.m_get_authorization_txid_ = CreateMaybeMessage< ::proto::get_authorization_txid >(GetArenaForAllocation());
  }
  return request_type_.m_get_authorization_txid_;
}
inline ::proto::get_authorization_txid* request::mutable_m_get_authorization_txid() {
  ::proto::get_authorization_txid* _msg = _internal_mutable_m_get_authorization_txid();
  // @@protoc_insertion_point(field_mutable:proto.request.m_get_authorization_txid)
  return _msg;
}

// .proto.get_all_finished_votings_for_voter m_get_all_finished_votings_for_voter = 12;
inline bool request::_internal_has_m_get_all_finished_votings_for_voter() const {
  return request_type_case() == kMGetAllFinishedVotingsForVoter;
}
inline bool request::has_m_get_all_finished_votings_for_voter() const {
  return _internal_has_m_get_all_finished_votings_for_voter();
}
inline void request::set_has_m_get_all_finished_votings_for_voter() {
  _oneof_case_[0] = kMGetAllFinishedVotingsForVoter;
}
inline void request::clear_m_get_all_finished_votings_for_voter() {
  if (_internal_has_m_get_all_finished_votings_for_voter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.m_get_all_finished_votings_for_voter_;
    }
    clear_has_request_type();
  }
}
inline ::proto::get_all_finished_votings_for_voter* request::release_m_get_all_finished_votings_for_voter() {
  // @@protoc_insertion_point(field_release:proto.request.m_get_all_finished_votings_for_voter)
  if (_internal_has_m_get_all_finished_votings_for_voter()) {
    clear_has_request_type();
      ::proto::get_all_finished_votings_for_voter* temp = request_type_.m_get_all_finished_votings_for_voter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.m_get_all_finished_votings_for_voter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::get_all_finished_votings_for_voter& request::_internal_m_get_all_finished_votings_for_voter() const {
  return _internal_has_m_get_all_finished_votings_for_voter()
      ? *request_type_.m_get_all_finished_votings_for_voter_
      : reinterpret_cast< ::proto::get_all_finished_votings_for_voter&>(::proto::_get_all_finished_votings_for_voter_default_instance_);
}
inline const ::proto::get_all_finished_votings_for_voter& request::m_get_all_finished_votings_for_voter() const {
  // @@protoc_insertion_point(field_get:proto.request.m_get_all_finished_votings_for_voter)
  return _internal_m_get_all_finished_votings_for_voter();
}
inline ::proto::get_all_finished_votings_for_voter* request::unsafe_arena_release_m_get_all_finished_votings_for_voter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.request.m_get_all_finished_votings_for_voter)
  if (_internal_has_m_get_all_finished_votings_for_voter()) {
    clear_has_request_type();
    ::proto::get_all_finished_votings_for_voter* temp = request_type_.m_get_all_finished_votings_for_voter_;
    request_type_.m_get_all_finished_votings_for_voter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void request::unsafe_arena_set_allocated_m_get_all_finished_votings_for_voter(::proto::get_all_finished_votings_for_voter* m_get_all_finished_votings_for_voter) {
  clear_request_type();
  if (m_get_all_finished_votings_for_voter) {
    set_has_m_get_all_finished_votings_for_voter();
    request_type_.m_get_all_finished_votings_for_voter_ = m_get_all_finished_votings_for_voter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.request.m_get_all_finished_votings_for_voter)
}
inline ::proto::get_all_finished_votings_for_voter* request::_internal_mutable_m_get_all_finished_votings_for_voter() {
  if (!_internal_has_m_get_all_finished_votings_for_voter()) {
    clear_request_type();
    set_has_m_get_all_finished_votings_for_voter();
    request_type_.m_get_all_finished_votings_for_voter_ = CreateMaybeMessage< ::proto::get_all_finished_votings_for_voter >(GetArenaForAllocation());
  }
  return request_type_.m_get_all_finished_votings_for_voter_;
}
inline ::proto::get_all_finished_votings_for_voter* request::mutable_m_get_all_finished_votings_for_voter() {
  ::proto::get_all_finished_votings_for_voter* _msg = _internal_mutable_m_get_all_finished_votings_for_voter();
  // @@protoc_insertion_point(field_mutable:proto.request.m_get_all_finished_votings_for_voter)
  return _msg;
}

inline bool request::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void request::clear_has_request_type() {
  _oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline request::RequestTypeCase request::request_type_case() const {
  return request::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// proto_massage

// .proto.request m_request = 1;
inline bool proto_massage::_internal_has_m_request() const {
  return message_type_case() == kMRequest;
}
inline bool proto_massage::has_m_request() const {
  return _internal_has_m_request();
}
inline void proto_massage::set_has_m_request() {
  _oneof_case_[0] = kMRequest;
}
inline void proto_massage::clear_m_request() {
  if (_internal_has_m_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_request_;
    }
    clear_has_message_type();
  }
}
inline ::proto::request* proto_massage::release_m_request() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_request)
  if (_internal_has_m_request()) {
    clear_has_message_type();
      ::proto::request* temp = message_type_.m_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::request& proto_massage::_internal_m_request() const {
  return _internal_has_m_request()
      ? *message_type_.m_request_
      : reinterpret_cast< ::proto::request&>(::proto::_request_default_instance_);
}
inline const ::proto::request& proto_massage::m_request() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_request)
  return _internal_m_request();
}
inline ::proto::request* proto_massage::unsafe_arena_release_m_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_request)
  if (_internal_has_m_request()) {
    clear_has_message_type();
    ::proto::request* temp = message_type_.m_request_;
    message_type_.m_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_request(::proto::request* m_request) {
  clear_message_type();
  if (m_request) {
    set_has_m_request();
    message_type_.m_request_ = m_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_request)
}
inline ::proto::request* proto_massage::_internal_mutable_m_request() {
  if (!_internal_has_m_request()) {
    clear_message_type();
    set_has_m_request();
    message_type_.m_request_ = CreateMaybeMessage< ::proto::request >(GetArenaForAllocation());
  }
  return message_type_.m_request_;
}
inline ::proto::request* proto_massage::mutable_m_request() {
  ::proto::request* _msg = _internal_mutable_m_request();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_request)
  return _msg;
}

// .proto.headers m_headers = 2;
inline bool proto_massage::_internal_has_m_headers() const {
  return message_type_case() == kMHeaders;
}
inline bool proto_massage::has_m_headers() const {
  return _internal_has_m_headers();
}
inline void proto_massage::set_has_m_headers() {
  _oneof_case_[0] = kMHeaders;
}
inline void proto_massage::clear_m_headers() {
  if (_internal_has_m_headers()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_headers_;
    }
    clear_has_message_type();
  }
}
inline ::proto::headers* proto_massage::release_m_headers() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_headers)
  if (_internal_has_m_headers()) {
    clear_has_message_type();
      ::proto::headers* temp = message_type_.m_headers_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_headers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::headers& proto_massage::_internal_m_headers() const {
  return _internal_has_m_headers()
      ? *message_type_.m_headers_
      : reinterpret_cast< ::proto::headers&>(::proto::_headers_default_instance_);
}
inline const ::proto::headers& proto_massage::m_headers() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_headers)
  return _internal_m_headers();
}
inline ::proto::headers* proto_massage::unsafe_arena_release_m_headers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_headers)
  if (_internal_has_m_headers()) {
    clear_has_message_type();
    ::proto::headers* temp = message_type_.m_headers_;
    message_type_.m_headers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_headers(::proto::headers* m_headers) {
  clear_message_type();
  if (m_headers) {
    set_has_m_headers();
    message_type_.m_headers_ = m_headers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_headers)
}
inline ::proto::headers* proto_massage::_internal_mutable_m_headers() {
  if (!_internal_has_m_headers()) {
    clear_message_type();
    set_has_m_headers();
    message_type_.m_headers_ = CreateMaybeMessage< ::proto::headers >(GetArenaForAllocation());
  }
  return message_type_.m_headers_;
}
inline ::proto::headers* proto_massage::mutable_m_headers() {
  ::proto::headers* _msg = _internal_mutable_m_headers();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_headers)
  return _msg;
}

// .proto.block m_block = 3;
inline bool proto_massage::_internal_has_m_block() const {
  return message_type_case() == kMBlock;
}
inline bool proto_massage::has_m_block() const {
  return _internal_has_m_block();
}
inline void proto_massage::set_has_m_block() {
  _oneof_case_[0] = kMBlock;
}
inline void proto_massage::clear_m_block() {
  if (_internal_has_m_block()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_block_;
    }
    clear_has_message_type();
  }
}
inline ::proto::block* proto_massage::release_m_block() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_block)
  if (_internal_has_m_block()) {
    clear_has_message_type();
      ::proto::block* temp = message_type_.m_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::block& proto_massage::_internal_m_block() const {
  return _internal_has_m_block()
      ? *message_type_.m_block_
      : reinterpret_cast< ::proto::block&>(::proto::_block_default_instance_);
}
inline const ::proto::block& proto_massage::m_block() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_block)
  return _internal_m_block();
}
inline ::proto::block* proto_massage::unsafe_arena_release_m_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_block)
  if (_internal_has_m_block()) {
    clear_has_message_type();
    ::proto::block* temp = message_type_.m_block_;
    message_type_.m_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_block(::proto::block* m_block) {
  clear_message_type();
  if (m_block) {
    set_has_m_block();
    message_type_.m_block_ = m_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_block)
}
inline ::proto::block* proto_massage::_internal_mutable_m_block() {
  if (!_internal_has_m_block()) {
    clear_message_type();
    set_has_m_block();
    message_type_.m_block_ = CreateMaybeMessage< ::proto::block >(GetArenaForAllocation());
  }
  return message_type_.m_block_;
}
inline ::proto::block* proto_massage::mutable_m_block() {
  ::proto::block* _msg = _internal_mutable_m_block();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_block)
  return _msg;
}

// .proto.transaction m_transaction = 4;
inline bool proto_massage::_internal_has_m_transaction() const {
  return message_type_case() == kMTransaction;
}
inline bool proto_massage::has_m_transaction() const {
  return _internal_has_m_transaction();
}
inline void proto_massage::set_has_m_transaction() {
  _oneof_case_[0] = kMTransaction;
}
inline void proto_massage::clear_m_transaction() {
  if (_internal_has_m_transaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_transaction_;
    }
    clear_has_message_type();
  }
}
inline ::proto::transaction* proto_massage::release_m_transaction() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_transaction)
  if (_internal_has_m_transaction()) {
    clear_has_message_type();
      ::proto::transaction* temp = message_type_.m_transaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::transaction& proto_massage::_internal_m_transaction() const {
  return _internal_has_m_transaction()
      ? *message_type_.m_transaction_
      : reinterpret_cast< ::proto::transaction&>(::proto::_transaction_default_instance_);
}
inline const ::proto::transaction& proto_massage::m_transaction() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_transaction)
  return _internal_m_transaction();
}
inline ::proto::transaction* proto_massage::unsafe_arena_release_m_transaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_transaction)
  if (_internal_has_m_transaction()) {
    clear_has_message_type();
    ::proto::transaction* temp = message_type_.m_transaction_;
    message_type_.m_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_transaction(::proto::transaction* m_transaction) {
  clear_message_type();
  if (m_transaction) {
    set_has_m_transaction();
    message_type_.m_transaction_ = m_transaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_transaction)
}
inline ::proto::transaction* proto_massage::_internal_mutable_m_transaction() {
  if (!_internal_has_m_transaction()) {
    clear_message_type();
    set_has_m_transaction();
    message_type_.m_transaction_ = CreateMaybeMessage< ::proto::transaction >(GetArenaForAllocation());
  }
  return message_type_.m_transaction_;
}
inline ::proto::transaction* proto_massage::mutable_m_transaction() {
  ::proto::transaction* _msg = _internal_mutable_m_transaction();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_transaction)
  return _msg;
}

// .proto.addr m_addr = 5;
inline bool proto_massage::_internal_has_m_addr() const {
  return message_type_case() == kMAddr;
}
inline bool proto_massage::has_m_addr() const {
  return _internal_has_m_addr();
}
inline void proto_massage::set_has_m_addr() {
  _oneof_case_[0] = kMAddr;
}
inline void proto_massage::clear_m_addr() {
  if (_internal_has_m_addr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_addr_;
    }
    clear_has_message_type();
  }
}
inline ::proto::addr* proto_massage::release_m_addr() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_addr)
  if (_internal_has_m_addr()) {
    clear_has_message_type();
      ::proto::addr* temp = message_type_.m_addr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_addr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::addr& proto_massage::_internal_m_addr() const {
  return _internal_has_m_addr()
      ? *message_type_.m_addr_
      : reinterpret_cast< ::proto::addr&>(::proto::_addr_default_instance_);
}
inline const ::proto::addr& proto_massage::m_addr() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_addr)
  return _internal_m_addr();
}
inline ::proto::addr* proto_massage::unsafe_arena_release_m_addr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_addr)
  if (_internal_has_m_addr()) {
    clear_has_message_type();
    ::proto::addr* temp = message_type_.m_addr_;
    message_type_.m_addr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_addr(::proto::addr* m_addr) {
  clear_message_type();
  if (m_addr) {
    set_has_m_addr();
    message_type_.m_addr_ = m_addr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_addr)
}
inline ::proto::addr* proto_massage::_internal_mutable_m_addr() {
  if (!_internal_has_m_addr()) {
    clear_message_type();
    set_has_m_addr();
    message_type_.m_addr_ = CreateMaybeMessage< ::proto::addr >(GetArenaForAllocation());
  }
  return message_type_.m_addr_;
}
inline ::proto::addr* proto_massage::mutable_m_addr() {
  ::proto::addr* _msg = _internal_mutable_m_addr();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_addr)
  return _msg;
}

// .proto.merkle_branch m_merkle_branch = 7;
inline bool proto_massage::_internal_has_m_merkle_branch() const {
  return message_type_case() == kMMerkleBranch;
}
inline bool proto_massage::has_m_merkle_branch() const {
  return _internal_has_m_merkle_branch();
}
inline void proto_massage::set_has_m_merkle_branch() {
  _oneof_case_[0] = kMMerkleBranch;
}
inline void proto_massage::clear_m_merkle_branch() {
  if (_internal_has_m_merkle_branch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_merkle_branch_;
    }
    clear_has_message_type();
  }
}
inline ::proto::merkle_branch* proto_massage::release_m_merkle_branch() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_merkle_branch)
  if (_internal_has_m_merkle_branch()) {
    clear_has_message_type();
      ::proto::merkle_branch* temp = message_type_.m_merkle_branch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_merkle_branch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::merkle_branch& proto_massage::_internal_m_merkle_branch() const {
  return _internal_has_m_merkle_branch()
      ? *message_type_.m_merkle_branch_
      : reinterpret_cast< ::proto::merkle_branch&>(::proto::_merkle_branch_default_instance_);
}
inline const ::proto::merkle_branch& proto_massage::m_merkle_branch() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_merkle_branch)
  return _internal_m_merkle_branch();
}
inline ::proto::merkle_branch* proto_massage::unsafe_arena_release_m_merkle_branch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_merkle_branch)
  if (_internal_has_m_merkle_branch()) {
    clear_has_message_type();
    ::proto::merkle_branch* temp = message_type_.m_merkle_branch_;
    message_type_.m_merkle_branch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_merkle_branch(::proto::merkle_branch* m_merkle_branch) {
  clear_message_type();
  if (m_merkle_branch) {
    set_has_m_merkle_branch();
    message_type_.m_merkle_branch_ = m_merkle_branch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_merkle_branch)
}
inline ::proto::merkle_branch* proto_massage::_internal_mutable_m_merkle_branch() {
  if (!_internal_has_m_merkle_branch()) {
    clear_message_type();
    set_has_m_merkle_branch();
    message_type_.m_merkle_branch_ = CreateMaybeMessage< ::proto::merkle_branch >(GetArenaForAllocation());
  }
  return message_type_.m_merkle_branch_;
}
inline ::proto::merkle_branch* proto_massage::mutable_m_merkle_branch() {
  ::proto::merkle_branch* _msg = _internal_mutable_m_merkle_branch();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_merkle_branch)
  return _msg;
}

// .proto.all_active_votings_for_voter m_all_active_votings_for_voter = 8;
inline bool proto_massage::_internal_has_m_all_active_votings_for_voter() const {
  return message_type_case() == kMAllActiveVotingsForVoter;
}
inline bool proto_massage::has_m_all_active_votings_for_voter() const {
  return _internal_has_m_all_active_votings_for_voter();
}
inline void proto_massage::set_has_m_all_active_votings_for_voter() {
  _oneof_case_[0] = kMAllActiveVotingsForVoter;
}
inline void proto_massage::clear_m_all_active_votings_for_voter() {
  if (_internal_has_m_all_active_votings_for_voter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_all_active_votings_for_voter_;
    }
    clear_has_message_type();
  }
}
inline ::proto::all_active_votings_for_voter* proto_massage::release_m_all_active_votings_for_voter() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_all_active_votings_for_voter)
  if (_internal_has_m_all_active_votings_for_voter()) {
    clear_has_message_type();
      ::proto::all_active_votings_for_voter* temp = message_type_.m_all_active_votings_for_voter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_all_active_votings_for_voter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::all_active_votings_for_voter& proto_massage::_internal_m_all_active_votings_for_voter() const {
  return _internal_has_m_all_active_votings_for_voter()
      ? *message_type_.m_all_active_votings_for_voter_
      : reinterpret_cast< ::proto::all_active_votings_for_voter&>(::proto::_all_active_votings_for_voter_default_instance_);
}
inline const ::proto::all_active_votings_for_voter& proto_massage::m_all_active_votings_for_voter() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_all_active_votings_for_voter)
  return _internal_m_all_active_votings_for_voter();
}
inline ::proto::all_active_votings_for_voter* proto_massage::unsafe_arena_release_m_all_active_votings_for_voter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_all_active_votings_for_voter)
  if (_internal_has_m_all_active_votings_for_voter()) {
    clear_has_message_type();
    ::proto::all_active_votings_for_voter* temp = message_type_.m_all_active_votings_for_voter_;
    message_type_.m_all_active_votings_for_voter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_all_active_votings_for_voter(::proto::all_active_votings_for_voter* m_all_active_votings_for_voter) {
  clear_message_type();
  if (m_all_active_votings_for_voter) {
    set_has_m_all_active_votings_for_voter();
    message_type_.m_all_active_votings_for_voter_ = m_all_active_votings_for_voter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_all_active_votings_for_voter)
}
inline ::proto::all_active_votings_for_voter* proto_massage::_internal_mutable_m_all_active_votings_for_voter() {
  if (!_internal_has_m_all_active_votings_for_voter()) {
    clear_message_type();
    set_has_m_all_active_votings_for_voter();
    message_type_.m_all_active_votings_for_voter_ = CreateMaybeMessage< ::proto::all_active_votings_for_voter >(GetArenaForAllocation());
  }
  return message_type_.m_all_active_votings_for_voter_;
}
inline ::proto::all_active_votings_for_voter* proto_massage::mutable_m_all_active_votings_for_voter() {
  ::proto::all_active_votings_for_voter* _msg = _internal_mutable_m_all_active_votings_for_voter();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_all_active_votings_for_voter)
  return _msg;
}

// .proto.amount_on_pkh m_amount_on_pkh = 9;
inline bool proto_massage::_internal_has_m_amount_on_pkh() const {
  return message_type_case() == kMAmountOnPkh;
}
inline bool proto_massage::has_m_amount_on_pkh() const {
  return _internal_has_m_amount_on_pkh();
}
inline void proto_massage::set_has_m_amount_on_pkh() {
  _oneof_case_[0] = kMAmountOnPkh;
}
inline void proto_massage::clear_m_amount_on_pkh() {
  if (_internal_has_m_amount_on_pkh()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_amount_on_pkh_;
    }
    clear_has_message_type();
  }
}
inline ::proto::amount_on_pkh* proto_massage::release_m_amount_on_pkh() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_amount_on_pkh)
  if (_internal_has_m_amount_on_pkh()) {
    clear_has_message_type();
      ::proto::amount_on_pkh* temp = message_type_.m_amount_on_pkh_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_amount_on_pkh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::amount_on_pkh& proto_massage::_internal_m_amount_on_pkh() const {
  return _internal_has_m_amount_on_pkh()
      ? *message_type_.m_amount_on_pkh_
      : reinterpret_cast< ::proto::amount_on_pkh&>(::proto::_amount_on_pkh_default_instance_);
}
inline const ::proto::amount_on_pkh& proto_massage::m_amount_on_pkh() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_amount_on_pkh)
  return _internal_m_amount_on_pkh();
}
inline ::proto::amount_on_pkh* proto_massage::unsafe_arena_release_m_amount_on_pkh() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_amount_on_pkh)
  if (_internal_has_m_amount_on_pkh()) {
    clear_has_message_type();
    ::proto::amount_on_pkh* temp = message_type_.m_amount_on_pkh_;
    message_type_.m_amount_on_pkh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_amount_on_pkh(::proto::amount_on_pkh* m_amount_on_pkh) {
  clear_message_type();
  if (m_amount_on_pkh) {
    set_has_m_amount_on_pkh();
    message_type_.m_amount_on_pkh_ = m_amount_on_pkh;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_amount_on_pkh)
}
inline ::proto::amount_on_pkh* proto_massage::_internal_mutable_m_amount_on_pkh() {
  if (!_internal_has_m_amount_on_pkh()) {
    clear_message_type();
    set_has_m_amount_on_pkh();
    message_type_.m_amount_on_pkh_ = CreateMaybeMessage< ::proto::amount_on_pkh >(GetArenaForAllocation());
  }
  return message_type_.m_amount_on_pkh_;
}
inline ::proto::amount_on_pkh* proto_massage::mutable_m_amount_on_pkh() {
  ::proto::amount_on_pkh* _msg = _internal_mutable_m_amount_on_pkh();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_amount_on_pkh)
  return _msg;
}

// .proto.authorization_txid m_authorization_txid = 10;
inline bool proto_massage::_internal_has_m_authorization_txid() const {
  return message_type_case() == kMAuthorizationTxid;
}
inline bool proto_massage::has_m_authorization_txid() const {
  return _internal_has_m_authorization_txid();
}
inline void proto_massage::set_has_m_authorization_txid() {
  _oneof_case_[0] = kMAuthorizationTxid;
}
inline void proto_massage::clear_m_authorization_txid() {
  if (_internal_has_m_authorization_txid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_authorization_txid_;
    }
    clear_has_message_type();
  }
}
inline ::proto::authorization_txid* proto_massage::release_m_authorization_txid() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_authorization_txid)
  if (_internal_has_m_authorization_txid()) {
    clear_has_message_type();
      ::proto::authorization_txid* temp = message_type_.m_authorization_txid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_authorization_txid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::authorization_txid& proto_massage::_internal_m_authorization_txid() const {
  return _internal_has_m_authorization_txid()
      ? *message_type_.m_authorization_txid_
      : reinterpret_cast< ::proto::authorization_txid&>(::proto::_authorization_txid_default_instance_);
}
inline const ::proto::authorization_txid& proto_massage::m_authorization_txid() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_authorization_txid)
  return _internal_m_authorization_txid();
}
inline ::proto::authorization_txid* proto_massage::unsafe_arena_release_m_authorization_txid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_authorization_txid)
  if (_internal_has_m_authorization_txid()) {
    clear_has_message_type();
    ::proto::authorization_txid* temp = message_type_.m_authorization_txid_;
    message_type_.m_authorization_txid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_authorization_txid(::proto::authorization_txid* m_authorization_txid) {
  clear_message_type();
  if (m_authorization_txid) {
    set_has_m_authorization_txid();
    message_type_.m_authorization_txid_ = m_authorization_txid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_authorization_txid)
}
inline ::proto::authorization_txid* proto_massage::_internal_mutable_m_authorization_txid() {
  if (!_internal_has_m_authorization_txid()) {
    clear_message_type();
    set_has_m_authorization_txid();
    message_type_.m_authorization_txid_ = CreateMaybeMessage< ::proto::authorization_txid >(GetArenaForAllocation());
  }
  return message_type_.m_authorization_txid_;
}
inline ::proto::authorization_txid* proto_massage::mutable_m_authorization_txid() {
  ::proto::authorization_txid* _msg = _internal_mutable_m_authorization_txid();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_authorization_txid)
  return _msg;
}

// .proto.all_finished_votings_for_voter m_all_finished_votings_for_voter = 11;
inline bool proto_massage::_internal_has_m_all_finished_votings_for_voter() const {
  return message_type_case() == kMAllFinishedVotingsForVoter;
}
inline bool proto_massage::has_m_all_finished_votings_for_voter() const {
  return _internal_has_m_all_finished_votings_for_voter();
}
inline void proto_massage::set_has_m_all_finished_votings_for_voter() {
  _oneof_case_[0] = kMAllFinishedVotingsForVoter;
}
inline void proto_massage::clear_m_all_finished_votings_for_voter() {
  if (_internal_has_m_all_finished_votings_for_voter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_type_.m_all_finished_votings_for_voter_;
    }
    clear_has_message_type();
  }
}
inline ::proto::all_finished_votings_for_voter* proto_massage::release_m_all_finished_votings_for_voter() {
  // @@protoc_insertion_point(field_release:proto.proto_massage.m_all_finished_votings_for_voter)
  if (_internal_has_m_all_finished_votings_for_voter()) {
    clear_has_message_type();
      ::proto::all_finished_votings_for_voter* temp = message_type_.m_all_finished_votings_for_voter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.m_all_finished_votings_for_voter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::all_finished_votings_for_voter& proto_massage::_internal_m_all_finished_votings_for_voter() const {
  return _internal_has_m_all_finished_votings_for_voter()
      ? *message_type_.m_all_finished_votings_for_voter_
      : reinterpret_cast< ::proto::all_finished_votings_for_voter&>(::proto::_all_finished_votings_for_voter_default_instance_);
}
inline const ::proto::all_finished_votings_for_voter& proto_massage::m_all_finished_votings_for_voter() const {
  // @@protoc_insertion_point(field_get:proto.proto_massage.m_all_finished_votings_for_voter)
  return _internal_m_all_finished_votings_for_voter();
}
inline ::proto::all_finished_votings_for_voter* proto_massage::unsafe_arena_release_m_all_finished_votings_for_voter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.proto_massage.m_all_finished_votings_for_voter)
  if (_internal_has_m_all_finished_votings_for_voter()) {
    clear_has_message_type();
    ::proto::all_finished_votings_for_voter* temp = message_type_.m_all_finished_votings_for_voter_;
    message_type_.m_all_finished_votings_for_voter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void proto_massage::unsafe_arena_set_allocated_m_all_finished_votings_for_voter(::proto::all_finished_votings_for_voter* m_all_finished_votings_for_voter) {
  clear_message_type();
  if (m_all_finished_votings_for_voter) {
    set_has_m_all_finished_votings_for_voter();
    message_type_.m_all_finished_votings_for_voter_ = m_all_finished_votings_for_voter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.proto_massage.m_all_finished_votings_for_voter)
}
inline ::proto::all_finished_votings_for_voter* proto_massage::_internal_mutable_m_all_finished_votings_for_voter() {
  if (!_internal_has_m_all_finished_votings_for_voter()) {
    clear_message_type();
    set_has_m_all_finished_votings_for_voter();
    message_type_.m_all_finished_votings_for_voter_ = CreateMaybeMessage< ::proto::all_finished_votings_for_voter >(GetArenaForAllocation());
  }
  return message_type_.m_all_finished_votings_for_voter_;
}
inline ::proto::all_finished_votings_for_voter* proto_massage::mutable_m_all_finished_votings_for_voter() {
  ::proto::all_finished_votings_for_voter* _msg = _internal_mutable_m_all_finished_votings_for_voter();
  // @@protoc_insertion_point(field_mutable:proto.proto_massage.m_all_finished_votings_for_voter)
  return _msg;
}

inline bool proto_massage::has_message_type() const {
  return message_type_case() != MESSAGE_TYPE_NOT_SET;
}
inline void proto_massage::clear_has_message_type() {
  _oneof_case_[0] = MESSAGE_TYPE_NOT_SET;
}
inline proto_massage::MessageTypeCase proto_massage::message_type_case() const {
  return proto_massage::MessageTypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::transaction_transactiontype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::transaction_transactiontype>() {
  return ::proto::transaction_transactiontype_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_p2p_2eproto
